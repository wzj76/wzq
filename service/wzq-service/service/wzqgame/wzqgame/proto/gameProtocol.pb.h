// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gameProtocol.proto

#ifndef PROTOBUF_gameProtocol_2eproto__INCLUDED
#define PROTOBUF_gameProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_gameProtocol_2eproto();
void protobuf_AssignDesc_gameProtocol_2eproto();
void protobuf_ShutdownFile_gameProtocol_2eproto();

class REQHold;
class ACKHold;
class MsgPackage;
class UserInfo;
class REQCreatGame;
class ACKCreatGame;
class REQAction;
class ACKAction;
class Position;
class REQGameOver;
class REQExitGame;
class ACKExitGame;
class REQForcExit;
class REQAskUndoChess;
class ACKAskUndoChess;
class REQChat;
class ACKChatText;
class REQContinueGame;
class ACKContinueGame;
class REQAskContinueGame;
class ACKAskContinueGame;
class ACKRefuseContinueGame;

// ===================================================================

class REQHold : public ::google::protobuf::Message {
 public:
  REQHold();
  virtual ~REQHold();

  REQHold(const REQHold& from);

  inline REQHold& operator=(const REQHold& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQHold& default_instance();

  void Swap(REQHold* other);

  // implements Message ----------------------------------------------

  REQHold* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQHold& from);
  void MergeFrom(const REQHold& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:REQHold)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQHold* default_instance_;
};
// -------------------------------------------------------------------

class ACKHold : public ::google::protobuf::Message {
 public:
  ACKHold();
  virtual ~ACKHold();

  ACKHold(const ACKHold& from);

  inline ACKHold& operator=(const ACKHold& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKHold& default_instance();

  void Swap(ACKHold* other);

  // implements Message ----------------------------------------------

  ACKHold* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKHold& from);
  void MergeFrom(const ACKHold& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result_id = 1;
  inline bool has_result_id() const;
  inline void clear_result_id();
  static const int kResultIdFieldNumber = 1;
  inline ::google::protobuf::int32 result_id() const;
  inline void set_result_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ACKHold)
 private:
  inline void set_has_result_id();
  inline void clear_has_result_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKHold* default_instance_;
};
// -------------------------------------------------------------------

class MsgPackage : public ::google::protobuf::Message {
 public:
  MsgPackage();
  virtual ~MsgPackage();

  MsgPackage(const MsgPackage& from);

  inline MsgPackage& operator=(const MsgPackage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPackage& default_instance();

  void Swap(MsgPackage* other);

  // implements Message ----------------------------------------------

  MsgPackage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPackage& from);
  void MergeFrom(const MsgPackage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 msg_id = 1;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  inline ::google::protobuf::int64 msg_id() const;
  inline void set_msg_id(::google::protobuf::int64 value);

  // optional int64 seq_id = 2;
  inline bool has_seq_id() const;
  inline void clear_seq_id();
  static const int kSeqIdFieldNumber = 2;
  inline ::google::protobuf::int64 seq_id() const;
  inline void set_seq_id(::google::protobuf::int64 value);

  // optional int64 user_id = 3;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // optional bytes msg = 4;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 4;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // optional bytes src = 5;
  inline bool has_src() const;
  inline void clear_src();
  static const int kSrcFieldNumber = 5;
  inline const ::std::string& src() const;
  inline void set_src(const ::std::string& value);
  inline void set_src(const char* value);
  inline void set_src(const void* value, size_t size);
  inline ::std::string* mutable_src();
  inline ::std::string* release_src();
  inline void set_allocated_src(::std::string* src);

  // optional int64 clientid = 6;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 6;
  inline ::google::protobuf::int64 clientid() const;
  inline void set_clientid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:MsgPackage)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_seq_id();
  inline void clear_has_seq_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_src();
  inline void clear_has_src();
  inline void set_has_clientid();
  inline void clear_has_clientid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 msg_id_;
  ::google::protobuf::int64 seq_id_;
  ::google::protobuf::int64 user_id_;
  ::std::string* msg_;
  ::std::string* src_;
  ::google::protobuf::int64 clientid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static MsgPackage* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional bytes username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const void* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional int32 wintimes = 3;
  inline bool has_wintimes() const;
  inline void clear_wintimes();
  static const int kWintimesFieldNumber = 3;
  inline ::google::protobuf::int32 wintimes() const;
  inline void set_wintimes(::google::protobuf::int32 value);

  // optional int32 losetimes = 4;
  inline bool has_losetimes() const;
  inline void clear_losetimes();
  static const int kLosetimesFieldNumber = 4;
  inline ::google::protobuf::int32 losetimes() const;
  inline void set_losetimes(::google::protobuf::int32 value);

  // optional int32 score = 5;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 5;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // optional int32 level = 6;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 6;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 xp = 7;
  inline bool has_xp() const;
  inline void clear_xp();
  static const int kXpFieldNumber = 7;
  inline ::google::protobuf::int32 xp() const;
  inline void set_xp(::google::protobuf::int32 value);

  // optional int32 head_id = 8;
  inline bool has_head_id() const;
  inline void clear_head_id();
  static const int kHeadIdFieldNumber = 8;
  inline ::google::protobuf::int32 head_id() const;
  inline void set_head_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UserInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_wintimes();
  inline void clear_has_wintimes();
  inline void set_has_losetimes();
  inline void clear_has_losetimes();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_xp();
  inline void clear_has_xp();
  inline void set_has_head_id();
  inline void clear_has_head_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 wintimes_;
  ::google::protobuf::int32 losetimes_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 xp_;
  ::google::protobuf::int32 head_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class REQCreatGame : public ::google::protobuf::Message {
 public:
  REQCreatGame();
  virtual ~REQCreatGame();

  REQCreatGame(const REQCreatGame& from);

  inline REQCreatGame& operator=(const REQCreatGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQCreatGame& default_instance();

  void Swap(REQCreatGame* other);

  // implements Message ----------------------------------------------

  REQCreatGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQCreatGame& from);
  void MergeFrom(const REQCreatGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes req_msg = 1;
  inline bool has_req_msg() const;
  inline void clear_req_msg();
  static const int kReqMsgFieldNumber = 1;
  inline const ::std::string& req_msg() const;
  inline void set_req_msg(const ::std::string& value);
  inline void set_req_msg(const char* value);
  inline void set_req_msg(const void* value, size_t size);
  inline ::std::string* mutable_req_msg();
  inline ::std::string* release_req_msg();
  inline void set_allocated_req_msg(::std::string* req_msg);

  // optional .UserInfo userinfo_player1 = 2;
  inline bool has_userinfo_player1() const;
  inline void clear_userinfo_player1();
  static const int kUserinfoPlayer1FieldNumber = 2;
  inline const ::UserInfo& userinfo_player1() const;
  inline ::UserInfo* mutable_userinfo_player1();
  inline ::UserInfo* release_userinfo_player1();
  inline void set_allocated_userinfo_player1(::UserInfo* userinfo_player1);

  // optional int32 player1_clientid = 3;
  inline bool has_player1_clientid() const;
  inline void clear_player1_clientid();
  static const int kPlayer1ClientidFieldNumber = 3;
  inline ::google::protobuf::int32 player1_clientid() const;
  inline void set_player1_clientid(::google::protobuf::int32 value);

  // optional .UserInfo userinfo_player2 = 4;
  inline bool has_userinfo_player2() const;
  inline void clear_userinfo_player2();
  static const int kUserinfoPlayer2FieldNumber = 4;
  inline const ::UserInfo& userinfo_player2() const;
  inline ::UserInfo* mutable_userinfo_player2();
  inline ::UserInfo* release_userinfo_player2();
  inline void set_allocated_userinfo_player2(::UserInfo* userinfo_player2);

  // optional int32 player2_clientid = 5;
  inline bool has_player2_clientid() const;
  inline void clear_player2_clientid();
  static const int kPlayer2ClientidFieldNumber = 5;
  inline ::google::protobuf::int32 player2_clientid() const;
  inline void set_player2_clientid(::google::protobuf::int32 value);

  // optional int32 black_id = 6;
  inline bool has_black_id() const;
  inline void clear_black_id();
  static const int kBlackIdFieldNumber = 6;
  inline ::google::protobuf::int32 black_id() const;
  inline void set_black_id(::google::protobuf::int32 value);

  // optional int32 white_id = 7;
  inline bool has_white_id() const;
  inline void clear_white_id();
  static const int kWhiteIdFieldNumber = 7;
  inline ::google::protobuf::int32 white_id() const;
  inline void set_white_id(::google::protobuf::int32 value);

  // optional int32 board_row = 8;
  inline bool has_board_row() const;
  inline void clear_board_row();
  static const int kBoardRowFieldNumber = 8;
  inline ::google::protobuf::int32 board_row() const;
  inline void set_board_row(::google::protobuf::int32 value);

  // optional int32 board_col = 9;
  inline bool has_board_col() const;
  inline void clear_board_col();
  static const int kBoardColFieldNumber = 9;
  inline ::google::protobuf::int32 board_col() const;
  inline void set_board_col(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQCreatGame)
 private:
  inline void set_has_req_msg();
  inline void clear_has_req_msg();
  inline void set_has_userinfo_player1();
  inline void clear_has_userinfo_player1();
  inline void set_has_player1_clientid();
  inline void clear_has_player1_clientid();
  inline void set_has_userinfo_player2();
  inline void clear_has_userinfo_player2();
  inline void set_has_player2_clientid();
  inline void clear_has_player2_clientid();
  inline void set_has_black_id();
  inline void clear_has_black_id();
  inline void set_has_white_id();
  inline void clear_has_white_id();
  inline void set_has_board_row();
  inline void clear_has_board_row();
  inline void set_has_board_col();
  inline void clear_has_board_col();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* req_msg_;
  ::UserInfo* userinfo_player1_;
  ::UserInfo* userinfo_player2_;
  ::google::protobuf::int32 player1_clientid_;
  ::google::protobuf::int32 player2_clientid_;
  ::google::protobuf::int32 black_id_;
  ::google::protobuf::int32 white_id_;
  ::google::protobuf::int32 board_row_;
  ::google::protobuf::int32 board_col_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQCreatGame* default_instance_;
};
// -------------------------------------------------------------------

class ACKCreatGame : public ::google::protobuf::Message {
 public:
  ACKCreatGame();
  virtual ~ACKCreatGame();

  ACKCreatGame(const ACKCreatGame& from);

  inline ACKCreatGame& operator=(const ACKCreatGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKCreatGame& default_instance();

  void Swap(ACKCreatGame* other);

  // implements Message ----------------------------------------------

  ACKCreatGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKCreatGame& from);
  void MergeFrom(const ACKCreatGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required bytes result_msg = 2;
  inline bool has_result_msg() const;
  inline void clear_result_msg();
  static const int kResultMsgFieldNumber = 2;
  inline const ::std::string& result_msg() const;
  inline void set_result_msg(const ::std::string& value);
  inline void set_result_msg(const char* value);
  inline void set_result_msg(const void* value, size_t size);
  inline ::std::string* mutable_result_msg();
  inline ::std::string* release_result_msg();
  inline void set_allocated_result_msg(::std::string* result_msg);

  // required int32 room_id = 3;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 3;
  inline ::google::protobuf::int32 room_id() const;
  inline void set_room_id(::google::protobuf::int32 value);

  // required int32 black_id = 4;
  inline bool has_black_id() const;
  inline void clear_black_id();
  static const int kBlackIdFieldNumber = 4;
  inline ::google::protobuf::int32 black_id() const;
  inline void set_black_id(::google::protobuf::int32 value);

  // required int32 white_id = 5;
  inline bool has_white_id() const;
  inline void clear_white_id();
  static const int kWhiteIdFieldNumber = 5;
  inline ::google::protobuf::int32 white_id() const;
  inline void set_white_id(::google::protobuf::int32 value);

  // required int32 score = 6;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 6;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // required int32 coins = 7;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 7;
  inline ::google::protobuf::int32 coins() const;
  inline void set_coins(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ACKCreatGame)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_result_msg();
  inline void clear_has_result_msg();
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_black_id();
  inline void clear_has_black_id();
  inline void set_has_white_id();
  inline void clear_has_white_id();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_coins();
  inline void clear_has_coins();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_msg_;
  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 room_id_;
  ::google::protobuf::int32 black_id_;
  ::google::protobuf::int32 white_id_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 coins_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKCreatGame* default_instance_;
};
// -------------------------------------------------------------------

class REQAction : public ::google::protobuf::Message {
 public:
  REQAction();
  virtual ~REQAction();

  REQAction(const REQAction& from);

  inline REQAction& operator=(const REQAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQAction& default_instance();

  void Swap(REQAction* other);

  // implements Message ----------------------------------------------

  REQAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQAction& from);
  void MergeFrom(const REQAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes req_msg = 1;
  inline bool has_req_msg() const;
  inline void clear_req_msg();
  static const int kReqMsgFieldNumber = 1;
  inline const ::std::string& req_msg() const;
  inline void set_req_msg(const ::std::string& value);
  inline void set_req_msg(const char* value);
  inline void set_req_msg(const void* value, size_t size);
  inline ::std::string* mutable_req_msg();
  inline ::std::string* release_req_msg();
  inline void set_allocated_req_msg(::std::string* req_msg);

  // required int32 table_id = 2;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 2;
  inline ::google::protobuf::int32 table_id() const;
  inline void set_table_id(::google::protobuf::int32 value);

  // required int32 action_id = 3;
  inline bool has_action_id() const;
  inline void clear_action_id();
  static const int kActionIdFieldNumber = 3;
  inline ::google::protobuf::int32 action_id() const;
  inline void set_action_id(::google::protobuf::int32 value);

  // optional int32 action_board_row = 4;
  inline bool has_action_board_row() const;
  inline void clear_action_board_row();
  static const int kActionBoardRowFieldNumber = 4;
  inline ::google::protobuf::int32 action_board_row() const;
  inline void set_action_board_row(::google::protobuf::int32 value);

  // optional int32 action_board_col = 5;
  inline bool has_action_board_col() const;
  inline void clear_action_board_col();
  static const int kActionBoardColFieldNumber = 5;
  inline ::google::protobuf::int32 action_board_col() const;
  inline void set_action_board_col(::google::protobuf::int32 value);

  // optional int32 remain_time = 6;
  inline bool has_remain_time() const;
  inline void clear_remain_time();
  static const int kRemainTimeFieldNumber = 6;
  inline ::google::protobuf::int32 remain_time() const;
  inline void set_remain_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQAction)
 private:
  inline void set_has_req_msg();
  inline void clear_has_req_msg();
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_action_id();
  inline void clear_has_action_id();
  inline void set_has_action_board_row();
  inline void clear_has_action_board_row();
  inline void set_has_action_board_col();
  inline void clear_has_action_board_col();
  inline void set_has_remain_time();
  inline void clear_has_remain_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* req_msg_;
  ::google::protobuf::int32 table_id_;
  ::google::protobuf::int32 action_id_;
  ::google::protobuf::int32 action_board_row_;
  ::google::protobuf::int32 action_board_col_;
  ::google::protobuf::int32 remain_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQAction* default_instance_;
};
// -------------------------------------------------------------------

class ACKAction : public ::google::protobuf::Message {
 public:
  ACKAction();
  virtual ~ACKAction();

  ACKAction(const ACKAction& from);

  inline ACKAction& operator=(const ACKAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKAction& default_instance();

  void Swap(ACKAction* other);

  // implements Message ----------------------------------------------

  ACKAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKAction& from);
  void MergeFrom(const ACKAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes result_msg = 1;
  inline bool has_result_msg() const;
  inline void clear_result_msg();
  static const int kResultMsgFieldNumber = 1;
  inline const ::std::string& result_msg() const;
  inline void set_result_msg(const ::std::string& value);
  inline void set_result_msg(const char* value);
  inline void set_result_msg(const void* value, size_t size);
  inline ::std::string* mutable_result_msg();
  inline ::std::string* release_result_msg();
  inline void set_allocated_result_msg(::std::string* result_msg);

  // required int32 action_id = 2;
  inline bool has_action_id() const;
  inline void clear_action_id();
  static const int kActionIdFieldNumber = 2;
  inline ::google::protobuf::int32 action_id() const;
  inline void set_action_id(::google::protobuf::int32 value);

  // optional int32 action_board_row = 3;
  inline bool has_action_board_row() const;
  inline void clear_action_board_row();
  static const int kActionBoardRowFieldNumber = 3;
  inline ::google::protobuf::int32 action_board_row() const;
  inline void set_action_board_row(::google::protobuf::int32 value);

  // optional int32 action_board_col = 4;
  inline bool has_action_board_col() const;
  inline void clear_action_board_col();
  static const int kActionBoardColFieldNumber = 4;
  inline ::google::protobuf::int32 action_board_col() const;
  inline void set_action_board_col(::google::protobuf::int32 value);

  // optional bool is_win = 5;
  inline bool has_is_win() const;
  inline void clear_is_win();
  static const int kIsWinFieldNumber = 5;
  inline bool is_win() const;
  inline void set_is_win(bool value);

  // optional int32 win_id = 6;
  inline bool has_win_id() const;
  inline void clear_win_id();
  static const int kWinIdFieldNumber = 6;
  inline ::google::protobuf::int32 win_id() const;
  inline void set_win_id(::google::protobuf::int32 value);

  // optional int32 lose_id = 7;
  inline bool has_lose_id() const;
  inline void clear_lose_id();
  static const int kLoseIdFieldNumber = 7;
  inline ::google::protobuf::int32 lose_id() const;
  inline void set_lose_id(::google::protobuf::int32 value);

  // optional bytes win_msg = 8;
  inline bool has_win_msg() const;
  inline void clear_win_msg();
  static const int kWinMsgFieldNumber = 8;
  inline const ::std::string& win_msg() const;
  inline void set_win_msg(const ::std::string& value);
  inline void set_win_msg(const char* value);
  inline void set_win_msg(const void* value, size_t size);
  inline ::std::string* mutable_win_msg();
  inline ::std::string* release_win_msg();
  inline void set_allocated_win_msg(::std::string* win_msg);

  // @@protoc_insertion_point(class_scope:ACKAction)
 private:
  inline void set_has_result_msg();
  inline void clear_has_result_msg();
  inline void set_has_action_id();
  inline void clear_has_action_id();
  inline void set_has_action_board_row();
  inline void clear_has_action_board_row();
  inline void set_has_action_board_col();
  inline void clear_has_action_board_col();
  inline void set_has_is_win();
  inline void clear_has_is_win();
  inline void set_has_win_id();
  inline void clear_has_win_id();
  inline void set_has_lose_id();
  inline void clear_has_lose_id();
  inline void set_has_win_msg();
  inline void clear_has_win_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_msg_;
  ::google::protobuf::int32 action_id_;
  ::google::protobuf::int32 action_board_row_;
  ::google::protobuf::int32 action_board_col_;
  bool is_win_;
  ::google::protobuf::int32 win_id_;
  ::google::protobuf::int32 lose_id_;
  ::std::string* win_msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKAction* default_instance_;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  Position* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 row = 1;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 1;
  inline ::google::protobuf::int32 row() const;
  inline void set_row(::google::protobuf::int32 value);

  // required int32 col = 2;
  inline bool has_col() const;
  inline void clear_col();
  static const int kColFieldNumber = 2;
  inline ::google::protobuf::int32 col() const;
  inline void set_col(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Position)
 private:
  inline void set_has_row();
  inline void clear_has_row();
  inline void set_has_col();
  inline void clear_has_col();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 row_;
  ::google::protobuf::int32 col_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class REQGameOver : public ::google::protobuf::Message {
 public:
  REQGameOver();
  virtual ~REQGameOver();

  REQGameOver(const REQGameOver& from);

  inline REQGameOver& operator=(const REQGameOver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQGameOver& default_instance();

  void Swap(REQGameOver* other);

  // implements Message ----------------------------------------------

  REQGameOver* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQGameOver& from);
  void MergeFrom(const REQGameOver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 winner_id = 1;
  inline bool has_winner_id() const;
  inline void clear_winner_id();
  static const int kWinnerIdFieldNumber = 1;
  inline ::google::protobuf::int32 winner_id() const;
  inline void set_winner_id(::google::protobuf::int32 value);

  // optional int32 loser_id = 2;
  inline bool has_loser_id() const;
  inline void clear_loser_id();
  static const int kLoserIdFieldNumber = 2;
  inline ::google::protobuf::int32 loser_id() const;
  inline void set_loser_id(::google::protobuf::int32 value);

  // optional int32 score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // required int32 black_id = 4;
  inline bool has_black_id() const;
  inline void clear_black_id();
  static const int kBlackIdFieldNumber = 4;
  inline ::google::protobuf::int32 black_id() const;
  inline void set_black_id(::google::protobuf::int32 value);

  // required int32 white_id = 5;
  inline bool has_white_id() const;
  inline void clear_white_id();
  static const int kWhiteIdFieldNumber = 5;
  inline ::google::protobuf::int32 white_id() const;
  inline void set_white_id(::google::protobuf::int32 value);

  // required bool is_no_winner = 6;
  inline bool has_is_no_winner() const;
  inline void clear_is_no_winner();
  static const int kIsNoWinnerFieldNumber = 6;
  inline bool is_no_winner() const;
  inline void set_is_no_winner(bool value);

  // required bool is_force_exit = 7;
  inline bool has_is_force_exit() const;
  inline void clear_is_force_exit();
  static const int kIsForceExitFieldNumber = 7;
  inline bool is_force_exit() const;
  inline void set_is_force_exit(bool value);

  // repeated .Position black_positions = 8;
  inline int black_positions_size() const;
  inline void clear_black_positions();
  static const int kBlackPositionsFieldNumber = 8;
  inline const ::Position& black_positions(int index) const;
  inline ::Position* mutable_black_positions(int index);
  inline ::Position* add_black_positions();
  inline const ::google::protobuf::RepeatedPtrField< ::Position >&
      black_positions() const;
  inline ::google::protobuf::RepeatedPtrField< ::Position >*
      mutable_black_positions();

  // repeated .Position white_positions = 9;
  inline int white_positions_size() const;
  inline void clear_white_positions();
  static const int kWhitePositionsFieldNumber = 9;
  inline const ::Position& white_positions(int index) const;
  inline ::Position* mutable_white_positions(int index);
  inline ::Position* add_white_positions();
  inline const ::google::protobuf::RepeatedPtrField< ::Position >&
      white_positions() const;
  inline ::google::protobuf::RepeatedPtrField< ::Position >*
      mutable_white_positions();

  // required int32 conis = 10;
  inline bool has_conis() const;
  inline void clear_conis();
  static const int kConisFieldNumber = 10;
  inline ::google::protobuf::int32 conis() const;
  inline void set_conis(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQGameOver)
 private:
  inline void set_has_winner_id();
  inline void clear_has_winner_id();
  inline void set_has_loser_id();
  inline void clear_has_loser_id();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_black_id();
  inline void clear_has_black_id();
  inline void set_has_white_id();
  inline void clear_has_white_id();
  inline void set_has_is_no_winner();
  inline void clear_has_is_no_winner();
  inline void set_has_is_force_exit();
  inline void clear_has_is_force_exit();
  inline void set_has_conis();
  inline void clear_has_conis();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 winner_id_;
  ::google::protobuf::int32 loser_id_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 black_id_;
  ::google::protobuf::int32 white_id_;
  bool is_no_winner_;
  bool is_force_exit_;
  ::google::protobuf::RepeatedPtrField< ::Position > black_positions_;
  ::google::protobuf::RepeatedPtrField< ::Position > white_positions_;
  ::google::protobuf::int32 conis_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQGameOver* default_instance_;
};
// -------------------------------------------------------------------

class REQExitGame : public ::google::protobuf::Message {
 public:
  REQExitGame();
  virtual ~REQExitGame();

  REQExitGame(const REQExitGame& from);

  inline REQExitGame& operator=(const REQExitGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQExitGame& default_instance();

  void Swap(REQExitGame* other);

  // implements Message ----------------------------------------------

  REQExitGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQExitGame& from);
  void MergeFrom(const REQExitGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes req_msg = 1;
  inline bool has_req_msg() const;
  inline void clear_req_msg();
  static const int kReqMsgFieldNumber = 1;
  inline const ::std::string& req_msg() const;
  inline void set_req_msg(const ::std::string& value);
  inline void set_req_msg(const char* value);
  inline void set_req_msg(const void* value, size_t size);
  inline ::std::string* mutable_req_msg();
  inline ::std::string* release_req_msg();
  inline void set_allocated_req_msg(::std::string* req_msg);

  // optional int32 exit_table_id = 2;
  inline bool has_exit_table_id() const;
  inline void clear_exit_table_id();
  static const int kExitTableIdFieldNumber = 2;
  inline ::google::protobuf::int32 exit_table_id() const;
  inline void set_exit_table_id(::google::protobuf::int32 value);

  // required int32 exit_user_id = 3;
  inline bool has_exit_user_id() const;
  inline void clear_exit_user_id();
  static const int kExitUserIdFieldNumber = 3;
  inline ::google::protobuf::int32 exit_user_id() const;
  inline void set_exit_user_id(::google::protobuf::int32 value);

  // required int32 enemy_user_id = 4;
  inline bool has_enemy_user_id() const;
  inline void clear_enemy_user_id();
  static const int kEnemyUserIdFieldNumber = 4;
  inline ::google::protobuf::int32 enemy_user_id() const;
  inline void set_enemy_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQExitGame)
 private:
  inline void set_has_req_msg();
  inline void clear_has_req_msg();
  inline void set_has_exit_table_id();
  inline void clear_has_exit_table_id();
  inline void set_has_exit_user_id();
  inline void clear_has_exit_user_id();
  inline void set_has_enemy_user_id();
  inline void clear_has_enemy_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* req_msg_;
  ::google::protobuf::int32 exit_table_id_;
  ::google::protobuf::int32 exit_user_id_;
  ::google::protobuf::int32 enemy_user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQExitGame* default_instance_;
};
// -------------------------------------------------------------------

class ACKExitGame : public ::google::protobuf::Message {
 public:
  ACKExitGame();
  virtual ~ACKExitGame();

  ACKExitGame(const ACKExitGame& from);

  inline ACKExitGame& operator=(const ACKExitGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKExitGame& default_instance();

  void Swap(ACKExitGame* other);

  // implements Message ----------------------------------------------

  ACKExitGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKExitGame& from);
  void MergeFrom(const ACKExitGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required bytes result_msg = 2;
  inline bool has_result_msg() const;
  inline void clear_result_msg();
  static const int kResultMsgFieldNumber = 2;
  inline const ::std::string& result_msg() const;
  inline void set_result_msg(const ::std::string& value);
  inline void set_result_msg(const char* value);
  inline void set_result_msg(const void* value, size_t size);
  inline ::std::string* mutable_result_msg();
  inline ::std::string* release_result_msg();
  inline void set_allocated_result_msg(::std::string* result_msg);

  // optional int32 exit_table_id = 3;
  inline bool has_exit_table_id() const;
  inline void clear_exit_table_id();
  static const int kExitTableIdFieldNumber = 3;
  inline ::google::protobuf::int32 exit_table_id() const;
  inline void set_exit_table_id(::google::protobuf::int32 value);

  // optional int32 exit_user_id = 4;
  inline bool has_exit_user_id() const;
  inline void clear_exit_user_id();
  static const int kExitUserIdFieldNumber = 4;
  inline ::google::protobuf::int32 exit_user_id() const;
  inline void set_exit_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ACKExitGame)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_result_msg();
  inline void clear_has_result_msg();
  inline void set_has_exit_table_id();
  inline void clear_has_exit_table_id();
  inline void set_has_exit_user_id();
  inline void clear_has_exit_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_msg_;
  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 exit_table_id_;
  ::google::protobuf::int32 exit_user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKExitGame* default_instance_;
};
// -------------------------------------------------------------------

class REQForcExit : public ::google::protobuf::Message {
 public:
  REQForcExit();
  virtual ~REQForcExit();

  REQForcExit(const REQForcExit& from);

  inline REQForcExit& operator=(const REQForcExit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQForcExit& default_instance();

  void Swap(REQForcExit* other);

  // implements Message ----------------------------------------------

  REQForcExit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQForcExit& from);
  void MergeFrom(const REQForcExit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQForcExit)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQForcExit* default_instance_;
};
// -------------------------------------------------------------------

class REQAskUndoChess : public ::google::protobuf::Message {
 public:
  REQAskUndoChess();
  virtual ~REQAskUndoChess();

  REQAskUndoChess(const REQAskUndoChess& from);

  inline REQAskUndoChess& operator=(const REQAskUndoChess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQAskUndoChess& default_instance();

  void Swap(REQAskUndoChess* other);

  // implements Message ----------------------------------------------

  REQAskUndoChess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQAskUndoChess& from);
  void MergeFrom(const REQAskUndoChess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 table_id = 1;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 1;
  inline ::google::protobuf::int32 table_id() const;
  inline void set_table_id(::google::protobuf::int32 value);

  // required int32 action_id = 2;
  inline bool has_action_id() const;
  inline void clear_action_id();
  static const int kActionIdFieldNumber = 2;
  inline ::google::protobuf::int32 action_id() const;
  inline void set_action_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQAskUndoChess)
 private:
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_action_id();
  inline void clear_has_action_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 table_id_;
  ::google::protobuf::int32 action_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQAskUndoChess* default_instance_;
};
// -------------------------------------------------------------------

class ACKAskUndoChess : public ::google::protobuf::Message {
 public:
  ACKAskUndoChess();
  virtual ~ACKAskUndoChess();

  ACKAskUndoChess(const ACKAskUndoChess& from);

  inline ACKAskUndoChess& operator=(const ACKAskUndoChess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKAskUndoChess& default_instance();

  void Swap(ACKAskUndoChess* other);

  // implements Message ----------------------------------------------

  ACKAskUndoChess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKAskUndoChess& from);
  void MergeFrom(const ACKAskUndoChess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_agree_undo_chess = 1;
  inline bool has_is_agree_undo_chess() const;
  inline void clear_is_agree_undo_chess();
  static const int kIsAgreeUndoChessFieldNumber = 1;
  inline bool is_agree_undo_chess() const;
  inline void set_is_agree_undo_chess(bool value);

  // required int32 table_id = 2;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 2;
  inline ::google::protobuf::int32 table_id() const;
  inline void set_table_id(::google::protobuf::int32 value);

  // required int32 action_id = 3;
  inline bool has_action_id() const;
  inline void clear_action_id();
  static const int kActionIdFieldNumber = 3;
  inline ::google::protobuf::int32 action_id() const;
  inline void set_action_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ACKAskUndoChess)
 private:
  inline void set_has_is_agree_undo_chess();
  inline void clear_has_is_agree_undo_chess();
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_action_id();
  inline void clear_has_action_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_agree_undo_chess_;
  ::google::protobuf::int32 table_id_;
  ::google::protobuf::int32 action_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKAskUndoChess* default_instance_;
};
// -------------------------------------------------------------------

class REQChat : public ::google::protobuf::Message {
 public:
  REQChat();
  virtual ~REQChat();

  REQChat(const REQChat& from);

  inline REQChat& operator=(const REQChat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQChat& default_instance();

  void Swap(REQChat* other);

  // implements Message ----------------------------------------------

  REQChat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQChat& from);
  void MergeFrom(const REQChat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 table_id = 2;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 2;
  inline ::google::protobuf::int32 table_id() const;
  inline void set_table_id(::google::protobuf::int32 value);

  // required int32 opp_id = 3;
  inline bool has_opp_id() const;
  inline void clear_opp_id();
  static const int kOppIdFieldNumber = 3;
  inline ::google::protobuf::int32 opp_id() const;
  inline void set_opp_id(::google::protobuf::int32 value);

  // optional bytes text = 4;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 4;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const void* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:REQChat)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_opp_id();
  inline void clear_has_opp_id();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 table_id_;
  ::std::string* text_;
  ::google::protobuf::int32 opp_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQChat* default_instance_;
};
// -------------------------------------------------------------------

class ACKChatText : public ::google::protobuf::Message {
 public:
  ACKChatText();
  virtual ~ACKChatText();

  ACKChatText(const ACKChatText& from);

  inline ACKChatText& operator=(const ACKChatText& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKChatText& default_instance();

  void Swap(ACKChatText* other);

  // implements Message ----------------------------------------------

  ACKChatText* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKChatText& from);
  void MergeFrom(const ACKChatText& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 is_sensitive = 1;
  inline bool has_is_sensitive() const;
  inline void clear_is_sensitive();
  static const int kIsSensitiveFieldNumber = 1;
  inline ::google::protobuf::int32 is_sensitive() const;
  inline void set_is_sensitive(::google::protobuf::int32 value);

  // required int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 table_id = 3;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  inline ::google::protobuf::int32 table_id() const;
  inline void set_table_id(::google::protobuf::int32 value);

  // required int32 opp_id = 4;
  inline bool has_opp_id() const;
  inline void clear_opp_id();
  static const int kOppIdFieldNumber = 4;
  inline ::google::protobuf::int32 opp_id() const;
  inline void set_opp_id(::google::protobuf::int32 value);

  // optional bytes text = 5;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 5;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const void* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:ACKChatText)
 private:
  inline void set_has_is_sensitive();
  inline void clear_has_is_sensitive();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_opp_id();
  inline void clear_has_opp_id();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 is_sensitive_;
  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 table_id_;
  ::google::protobuf::int32 opp_id_;
  ::std::string* text_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKChatText* default_instance_;
};
// -------------------------------------------------------------------

class REQContinueGame : public ::google::protobuf::Message {
 public:
  REQContinueGame();
  virtual ~REQContinueGame();

  REQContinueGame(const REQContinueGame& from);

  inline REQContinueGame& operator=(const REQContinueGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQContinueGame& default_instance();

  void Swap(REQContinueGame* other);

  // implements Message ----------------------------------------------

  REQContinueGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQContinueGame& from);
  void MergeFrom(const REQContinueGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 enemy_user_id = 2;
  inline bool has_enemy_user_id() const;
  inline void clear_enemy_user_id();
  static const int kEnemyUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 enemy_user_id() const;
  inline void set_enemy_user_id(::google::protobuf::int32 value);

  // required int32 table_id = 3;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  inline ::google::protobuf::int32 table_id() const;
  inline void set_table_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQContinueGame)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_enemy_user_id();
  inline void clear_has_enemy_user_id();
  inline void set_has_table_id();
  inline void clear_has_table_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 enemy_user_id_;
  ::google::protobuf::int32 table_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQContinueGame* default_instance_;
};
// -------------------------------------------------------------------

class ACKContinueGame : public ::google::protobuf::Message {
 public:
  ACKContinueGame();
  virtual ~ACKContinueGame();

  ACKContinueGame(const ACKContinueGame& from);

  inline ACKContinueGame& operator=(const ACKContinueGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKContinueGame& default_instance();

  void Swap(ACKContinueGame* other);

  // implements Message ----------------------------------------------

  ACKContinueGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKContinueGame& from);
  void MergeFrom(const ACKContinueGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required bytes result_msg = 2;
  inline bool has_result_msg() const;
  inline void clear_result_msg();
  static const int kResultMsgFieldNumber = 2;
  inline const ::std::string& result_msg() const;
  inline void set_result_msg(const ::std::string& value);
  inline void set_result_msg(const char* value);
  inline void set_result_msg(const void* value, size_t size);
  inline ::std::string* mutable_result_msg();
  inline ::std::string* release_result_msg();
  inline void set_allocated_result_msg(::std::string* result_msg);

  // @@protoc_insertion_point(class_scope:ACKContinueGame)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_result_msg();
  inline void clear_has_result_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_msg_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKContinueGame* default_instance_;
};
// -------------------------------------------------------------------

class REQAskContinueGame : public ::google::protobuf::Message {
 public:
  REQAskContinueGame();
  virtual ~REQAskContinueGame();

  REQAskContinueGame(const REQAskContinueGame& from);

  inline REQAskContinueGame& operator=(const REQAskContinueGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQAskContinueGame& default_instance();

  void Swap(REQAskContinueGame* other);

  // implements Message ----------------------------------------------

  REQAskContinueGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQAskContinueGame& from);
  void MergeFrom(const REQAskContinueGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 enemy_user_id = 1;
  inline bool has_enemy_user_id() const;
  inline void clear_enemy_user_id();
  static const int kEnemyUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 enemy_user_id() const;
  inline void set_enemy_user_id(::google::protobuf::int32 value);

  // required int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 table_id = 3;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  inline ::google::protobuf::int32 table_id() const;
  inline void set_table_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQAskContinueGame)
 private:
  inline void set_has_enemy_user_id();
  inline void clear_has_enemy_user_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_table_id();
  inline void clear_has_table_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 enemy_user_id_;
  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 table_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQAskContinueGame* default_instance_;
};
// -------------------------------------------------------------------

class ACKAskContinueGame : public ::google::protobuf::Message {
 public:
  ACKAskContinueGame();
  virtual ~ACKAskContinueGame();

  ACKAskContinueGame(const ACKAskContinueGame& from);

  inline ACKAskContinueGame& operator=(const ACKAskContinueGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKAskContinueGame& default_instance();

  void Swap(ACKAskContinueGame* other);

  // implements Message ----------------------------------------------

  ACKAskContinueGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKAskContinueGame& from);
  void MergeFrom(const ACKAskContinueGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_agree_continue_game = 1;
  inline bool has_is_agree_continue_game() const;
  inline void clear_is_agree_continue_game();
  static const int kIsAgreeContinueGameFieldNumber = 1;
  inline bool is_agree_continue_game() const;
  inline void set_is_agree_continue_game(bool value);

  // required int32 enemy_user_id = 2;
  inline bool has_enemy_user_id() const;
  inline void clear_enemy_user_id();
  static const int kEnemyUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 enemy_user_id() const;
  inline void set_enemy_user_id(::google::protobuf::int32 value);

  // required int32 user_id = 3;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 table_id = 4;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 4;
  inline ::google::protobuf::int32 table_id() const;
  inline void set_table_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ACKAskContinueGame)
 private:
  inline void set_has_is_agree_continue_game();
  inline void clear_has_is_agree_continue_game();
  inline void set_has_enemy_user_id();
  inline void clear_has_enemy_user_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_table_id();
  inline void clear_has_table_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_agree_continue_game_;
  ::google::protobuf::int32 enemy_user_id_;
  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 table_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKAskContinueGame* default_instance_;
};
// -------------------------------------------------------------------

class ACKRefuseContinueGame : public ::google::protobuf::Message {
 public:
  ACKRefuseContinueGame();
  virtual ~ACKRefuseContinueGame();

  ACKRefuseContinueGame(const ACKRefuseContinueGame& from);

  inline ACKRefuseContinueGame& operator=(const ACKRefuseContinueGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKRefuseContinueGame& default_instance();

  void Swap(ACKRefuseContinueGame* other);

  // implements Message ----------------------------------------------

  ACKRefuseContinueGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKRefuseContinueGame& from);
  void MergeFrom(const ACKRefuseContinueGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required bytes result_msg = 2;
  inline bool has_result_msg() const;
  inline void clear_result_msg();
  static const int kResultMsgFieldNumber = 2;
  inline const ::std::string& result_msg() const;
  inline void set_result_msg(const ::std::string& value);
  inline void set_result_msg(const char* value);
  inline void set_result_msg(const void* value, size_t size);
  inline ::std::string* mutable_result_msg();
  inline ::std::string* release_result_msg();
  inline void set_allocated_result_msg(::std::string* result_msg);

  // @@protoc_insertion_point(class_scope:ACKRefuseContinueGame)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_result_msg();
  inline void clear_has_result_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_msg_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_gameProtocol_2eproto();
  friend void protobuf_AssignDesc_gameProtocol_2eproto();
  friend void protobuf_ShutdownFile_gameProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKRefuseContinueGame* default_instance_;
};
// ===================================================================


// ===================================================================

// REQHold

// -------------------------------------------------------------------

// ACKHold

// optional int32 result_id = 1;
inline bool ACKHold::has_result_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKHold::set_has_result_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKHold::clear_has_result_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKHold::clear_result_id() {
  result_id_ = 0;
  clear_has_result_id();
}
inline ::google::protobuf::int32 ACKHold::result_id() const {
  return result_id_;
}
inline void ACKHold::set_result_id(::google::protobuf::int32 value) {
  set_has_result_id();
  result_id_ = value;
}

// -------------------------------------------------------------------

// MsgPackage

// optional int64 msg_id = 1;
inline bool MsgPackage::has_msg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgPackage::set_has_msg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgPackage::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgPackage::clear_msg_id() {
  msg_id_ = GOOGLE_LONGLONG(0);
  clear_has_msg_id();
}
inline ::google::protobuf::int64 MsgPackage::msg_id() const {
  return msg_id_;
}
inline void MsgPackage::set_msg_id(::google::protobuf::int64 value) {
  set_has_msg_id();
  msg_id_ = value;
}

// optional int64 seq_id = 2;
inline bool MsgPackage::has_seq_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgPackage::set_has_seq_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgPackage::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgPackage::clear_seq_id() {
  seq_id_ = GOOGLE_LONGLONG(0);
  clear_has_seq_id();
}
inline ::google::protobuf::int64 MsgPackage::seq_id() const {
  return seq_id_;
}
inline void MsgPackage::set_seq_id(::google::protobuf::int64 value) {
  set_has_seq_id();
  seq_id_ = value;
}

// optional int64 user_id = 3;
inline bool MsgPackage::has_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgPackage::set_has_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgPackage::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgPackage::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 MsgPackage::user_id() const {
  return user_id_;
}
inline void MsgPackage::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
}

// optional bytes msg = 4;
inline bool MsgPackage::has_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgPackage::set_has_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgPackage::clear_has_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgPackage::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& MsgPackage::msg() const {
  return *msg_;
}
inline void MsgPackage::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void MsgPackage::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void MsgPackage::set_msg(const void* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgPackage::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* MsgPackage::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MsgPackage::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes src = 5;
inline bool MsgPackage::has_src() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgPackage::set_has_src() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgPackage::clear_has_src() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgPackage::clear_src() {
  if (src_ != &::google::protobuf::internal::kEmptyString) {
    src_->clear();
  }
  clear_has_src();
}
inline const ::std::string& MsgPackage::src() const {
  return *src_;
}
inline void MsgPackage::set_src(const ::std::string& value) {
  set_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    src_ = new ::std::string;
  }
  src_->assign(value);
}
inline void MsgPackage::set_src(const char* value) {
  set_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    src_ = new ::std::string;
  }
  src_->assign(value);
}
inline void MsgPackage::set_src(const void* value, size_t size) {
  set_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    src_ = new ::std::string;
  }
  src_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgPackage::mutable_src() {
  set_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    src_ = new ::std::string;
  }
  return src_;
}
inline ::std::string* MsgPackage::release_src() {
  clear_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src_;
    src_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MsgPackage::set_allocated_src(::std::string* src) {
  if (src_ != &::google::protobuf::internal::kEmptyString) {
    delete src_;
  }
  if (src) {
    set_has_src();
    src_ = src;
  } else {
    clear_has_src();
    src_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 clientid = 6;
inline bool MsgPackage::has_clientid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgPackage::set_has_clientid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgPackage::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgPackage::clear_clientid() {
  clientid_ = GOOGLE_LONGLONG(0);
  clear_has_clientid();
}
inline ::google::protobuf::int64 MsgPackage::clientid() const {
  return clientid_;
}
inline void MsgPackage::set_clientid(::google::protobuf::int64 value) {
  set_has_clientid();
  clientid_ = value;
}

// -------------------------------------------------------------------

// UserInfo

// optional int32 id = 1;
inline bool UserInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UserInfo::id() const {
  return id_;
}
inline void UserInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional bytes username = 2;
inline bool UserInfo::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& UserInfo::username() const {
  return *username_;
}
inline void UserInfo::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void UserInfo::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void UserInfo::set_username(const void* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* UserInfo::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 wintimes = 3;
inline bool UserInfo::has_wintimes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_wintimes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_wintimes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_wintimes() {
  wintimes_ = 0;
  clear_has_wintimes();
}
inline ::google::protobuf::int32 UserInfo::wintimes() const {
  return wintimes_;
}
inline void UserInfo::set_wintimes(::google::protobuf::int32 value) {
  set_has_wintimes();
  wintimes_ = value;
}

// optional int32 losetimes = 4;
inline bool UserInfo::has_losetimes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_losetimes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_losetimes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_losetimes() {
  losetimes_ = 0;
  clear_has_losetimes();
}
inline ::google::protobuf::int32 UserInfo::losetimes() const {
  return losetimes_;
}
inline void UserInfo::set_losetimes(::google::protobuf::int32 value) {
  set_has_losetimes();
  losetimes_ = value;
}

// optional int32 score = 5;
inline bool UserInfo::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 UserInfo::score() const {
  return score_;
}
inline void UserInfo::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// optional int32 level = 6;
inline bool UserInfo::has_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 UserInfo::level() const {
  return level_;
}
inline void UserInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 xp = 7;
inline bool UserInfo::has_xp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfo::set_has_xp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfo::clear_has_xp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfo::clear_xp() {
  xp_ = 0;
  clear_has_xp();
}
inline ::google::protobuf::int32 UserInfo::xp() const {
  return xp_;
}
inline void UserInfo::set_xp(::google::protobuf::int32 value) {
  set_has_xp();
  xp_ = value;
}

// optional int32 head_id = 8;
inline bool UserInfo::has_head_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfo::set_has_head_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfo::clear_has_head_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfo::clear_head_id() {
  head_id_ = 0;
  clear_has_head_id();
}
inline ::google::protobuf::int32 UserInfo::head_id() const {
  return head_id_;
}
inline void UserInfo::set_head_id(::google::protobuf::int32 value) {
  set_has_head_id();
  head_id_ = value;
}

// -------------------------------------------------------------------

// REQCreatGame

// required bytes req_msg = 1;
inline bool REQCreatGame::has_req_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQCreatGame::set_has_req_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQCreatGame::clear_has_req_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQCreatGame::clear_req_msg() {
  if (req_msg_ != &::google::protobuf::internal::kEmptyString) {
    req_msg_->clear();
  }
  clear_has_req_msg();
}
inline const ::std::string& REQCreatGame::req_msg() const {
  return *req_msg_;
}
inline void REQCreatGame::set_req_msg(const ::std::string& value) {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  req_msg_->assign(value);
}
inline void REQCreatGame::set_req_msg(const char* value) {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  req_msg_->assign(value);
}
inline void REQCreatGame::set_req_msg(const void* value, size_t size) {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  req_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQCreatGame::mutable_req_msg() {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  return req_msg_;
}
inline ::std::string* REQCreatGame::release_req_msg() {
  clear_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = req_msg_;
    req_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void REQCreatGame::set_allocated_req_msg(::std::string* req_msg) {
  if (req_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete req_msg_;
  }
  if (req_msg) {
    set_has_req_msg();
    req_msg_ = req_msg;
  } else {
    clear_has_req_msg();
    req_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .UserInfo userinfo_player1 = 2;
inline bool REQCreatGame::has_userinfo_player1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQCreatGame::set_has_userinfo_player1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQCreatGame::clear_has_userinfo_player1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQCreatGame::clear_userinfo_player1() {
  if (userinfo_player1_ != NULL) userinfo_player1_->::UserInfo::Clear();
  clear_has_userinfo_player1();
}
inline const ::UserInfo& REQCreatGame::userinfo_player1() const {
  return userinfo_player1_ != NULL ? *userinfo_player1_ : *default_instance_->userinfo_player1_;
}
inline ::UserInfo* REQCreatGame::mutable_userinfo_player1() {
  set_has_userinfo_player1();
  if (userinfo_player1_ == NULL) userinfo_player1_ = new ::UserInfo;
  return userinfo_player1_;
}
inline ::UserInfo* REQCreatGame::release_userinfo_player1() {
  clear_has_userinfo_player1();
  ::UserInfo* temp = userinfo_player1_;
  userinfo_player1_ = NULL;
  return temp;
}
inline void REQCreatGame::set_allocated_userinfo_player1(::UserInfo* userinfo_player1) {
  delete userinfo_player1_;
  userinfo_player1_ = userinfo_player1;
  if (userinfo_player1) {
    set_has_userinfo_player1();
  } else {
    clear_has_userinfo_player1();
  }
}

// optional int32 player1_clientid = 3;
inline bool REQCreatGame::has_player1_clientid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQCreatGame::set_has_player1_clientid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQCreatGame::clear_has_player1_clientid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQCreatGame::clear_player1_clientid() {
  player1_clientid_ = 0;
  clear_has_player1_clientid();
}
inline ::google::protobuf::int32 REQCreatGame::player1_clientid() const {
  return player1_clientid_;
}
inline void REQCreatGame::set_player1_clientid(::google::protobuf::int32 value) {
  set_has_player1_clientid();
  player1_clientid_ = value;
}

// optional .UserInfo userinfo_player2 = 4;
inline bool REQCreatGame::has_userinfo_player2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void REQCreatGame::set_has_userinfo_player2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void REQCreatGame::clear_has_userinfo_player2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void REQCreatGame::clear_userinfo_player2() {
  if (userinfo_player2_ != NULL) userinfo_player2_->::UserInfo::Clear();
  clear_has_userinfo_player2();
}
inline const ::UserInfo& REQCreatGame::userinfo_player2() const {
  return userinfo_player2_ != NULL ? *userinfo_player2_ : *default_instance_->userinfo_player2_;
}
inline ::UserInfo* REQCreatGame::mutable_userinfo_player2() {
  set_has_userinfo_player2();
  if (userinfo_player2_ == NULL) userinfo_player2_ = new ::UserInfo;
  return userinfo_player2_;
}
inline ::UserInfo* REQCreatGame::release_userinfo_player2() {
  clear_has_userinfo_player2();
  ::UserInfo* temp = userinfo_player2_;
  userinfo_player2_ = NULL;
  return temp;
}
inline void REQCreatGame::set_allocated_userinfo_player2(::UserInfo* userinfo_player2) {
  delete userinfo_player2_;
  userinfo_player2_ = userinfo_player2;
  if (userinfo_player2) {
    set_has_userinfo_player2();
  } else {
    clear_has_userinfo_player2();
  }
}

// optional int32 player2_clientid = 5;
inline bool REQCreatGame::has_player2_clientid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void REQCreatGame::set_has_player2_clientid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void REQCreatGame::clear_has_player2_clientid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void REQCreatGame::clear_player2_clientid() {
  player2_clientid_ = 0;
  clear_has_player2_clientid();
}
inline ::google::protobuf::int32 REQCreatGame::player2_clientid() const {
  return player2_clientid_;
}
inline void REQCreatGame::set_player2_clientid(::google::protobuf::int32 value) {
  set_has_player2_clientid();
  player2_clientid_ = value;
}

// optional int32 black_id = 6;
inline bool REQCreatGame::has_black_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void REQCreatGame::set_has_black_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void REQCreatGame::clear_has_black_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void REQCreatGame::clear_black_id() {
  black_id_ = 0;
  clear_has_black_id();
}
inline ::google::protobuf::int32 REQCreatGame::black_id() const {
  return black_id_;
}
inline void REQCreatGame::set_black_id(::google::protobuf::int32 value) {
  set_has_black_id();
  black_id_ = value;
}

// optional int32 white_id = 7;
inline bool REQCreatGame::has_white_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void REQCreatGame::set_has_white_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void REQCreatGame::clear_has_white_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void REQCreatGame::clear_white_id() {
  white_id_ = 0;
  clear_has_white_id();
}
inline ::google::protobuf::int32 REQCreatGame::white_id() const {
  return white_id_;
}
inline void REQCreatGame::set_white_id(::google::protobuf::int32 value) {
  set_has_white_id();
  white_id_ = value;
}

// optional int32 board_row = 8;
inline bool REQCreatGame::has_board_row() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void REQCreatGame::set_has_board_row() {
  _has_bits_[0] |= 0x00000080u;
}
inline void REQCreatGame::clear_has_board_row() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void REQCreatGame::clear_board_row() {
  board_row_ = 0;
  clear_has_board_row();
}
inline ::google::protobuf::int32 REQCreatGame::board_row() const {
  return board_row_;
}
inline void REQCreatGame::set_board_row(::google::protobuf::int32 value) {
  set_has_board_row();
  board_row_ = value;
}

// optional int32 board_col = 9;
inline bool REQCreatGame::has_board_col() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void REQCreatGame::set_has_board_col() {
  _has_bits_[0] |= 0x00000100u;
}
inline void REQCreatGame::clear_has_board_col() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void REQCreatGame::clear_board_col() {
  board_col_ = 0;
  clear_has_board_col();
}
inline ::google::protobuf::int32 REQCreatGame::board_col() const {
  return board_col_;
}
inline void REQCreatGame::set_board_col(::google::protobuf::int32 value) {
  set_has_board_col();
  board_col_ = value;
}

// -------------------------------------------------------------------

// ACKCreatGame

// required int32 code = 1;
inline bool ACKCreatGame::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKCreatGame::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKCreatGame::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKCreatGame::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKCreatGame::code() const {
  return code_;
}
inline void ACKCreatGame::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required bytes result_msg = 2;
inline bool ACKCreatGame::has_result_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKCreatGame::set_has_result_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKCreatGame::clear_has_result_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKCreatGame::clear_result_msg() {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    result_msg_->clear();
  }
  clear_has_result_msg();
}
inline const ::std::string& ACKCreatGame::result_msg() const {
  return *result_msg_;
}
inline void ACKCreatGame::set_result_msg(const ::std::string& value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKCreatGame::set_result_msg(const char* value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKCreatGame::set_result_msg(const void* value, size_t size) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKCreatGame::mutable_result_msg() {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  return result_msg_;
}
inline ::std::string* ACKCreatGame::release_result_msg() {
  clear_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_msg_;
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKCreatGame::set_allocated_result_msg(::std::string* result_msg) {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete result_msg_;
  }
  if (result_msg) {
    set_has_result_msg();
    result_msg_ = result_msg;
  } else {
    clear_has_result_msg();
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 room_id = 3;
inline bool ACKCreatGame::has_room_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKCreatGame::set_has_room_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKCreatGame::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKCreatGame::clear_room_id() {
  room_id_ = 0;
  clear_has_room_id();
}
inline ::google::protobuf::int32 ACKCreatGame::room_id() const {
  return room_id_;
}
inline void ACKCreatGame::set_room_id(::google::protobuf::int32 value) {
  set_has_room_id();
  room_id_ = value;
}

// required int32 black_id = 4;
inline bool ACKCreatGame::has_black_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACKCreatGame::set_has_black_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACKCreatGame::clear_has_black_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACKCreatGame::clear_black_id() {
  black_id_ = 0;
  clear_has_black_id();
}
inline ::google::protobuf::int32 ACKCreatGame::black_id() const {
  return black_id_;
}
inline void ACKCreatGame::set_black_id(::google::protobuf::int32 value) {
  set_has_black_id();
  black_id_ = value;
}

// required int32 white_id = 5;
inline bool ACKCreatGame::has_white_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ACKCreatGame::set_has_white_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ACKCreatGame::clear_has_white_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ACKCreatGame::clear_white_id() {
  white_id_ = 0;
  clear_has_white_id();
}
inline ::google::protobuf::int32 ACKCreatGame::white_id() const {
  return white_id_;
}
inline void ACKCreatGame::set_white_id(::google::protobuf::int32 value) {
  set_has_white_id();
  white_id_ = value;
}

// required int32 score = 6;
inline bool ACKCreatGame::has_score() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ACKCreatGame::set_has_score() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ACKCreatGame::clear_has_score() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ACKCreatGame::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 ACKCreatGame::score() const {
  return score_;
}
inline void ACKCreatGame::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// required int32 coins = 7;
inline bool ACKCreatGame::has_coins() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ACKCreatGame::set_has_coins() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ACKCreatGame::clear_has_coins() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ACKCreatGame::clear_coins() {
  coins_ = 0;
  clear_has_coins();
}
inline ::google::protobuf::int32 ACKCreatGame::coins() const {
  return coins_;
}
inline void ACKCreatGame::set_coins(::google::protobuf::int32 value) {
  set_has_coins();
  coins_ = value;
}

// -------------------------------------------------------------------

// REQAction

// required bytes req_msg = 1;
inline bool REQAction::has_req_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQAction::set_has_req_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQAction::clear_has_req_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQAction::clear_req_msg() {
  if (req_msg_ != &::google::protobuf::internal::kEmptyString) {
    req_msg_->clear();
  }
  clear_has_req_msg();
}
inline const ::std::string& REQAction::req_msg() const {
  return *req_msg_;
}
inline void REQAction::set_req_msg(const ::std::string& value) {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  req_msg_->assign(value);
}
inline void REQAction::set_req_msg(const char* value) {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  req_msg_->assign(value);
}
inline void REQAction::set_req_msg(const void* value, size_t size) {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  req_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQAction::mutable_req_msg() {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  return req_msg_;
}
inline ::std::string* REQAction::release_req_msg() {
  clear_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = req_msg_;
    req_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void REQAction::set_allocated_req_msg(::std::string* req_msg) {
  if (req_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete req_msg_;
  }
  if (req_msg) {
    set_has_req_msg();
    req_msg_ = req_msg;
  } else {
    clear_has_req_msg();
    req_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 table_id = 2;
inline bool REQAction::has_table_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQAction::set_has_table_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQAction::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQAction::clear_table_id() {
  table_id_ = 0;
  clear_has_table_id();
}
inline ::google::protobuf::int32 REQAction::table_id() const {
  return table_id_;
}
inline void REQAction::set_table_id(::google::protobuf::int32 value) {
  set_has_table_id();
  table_id_ = value;
}

// required int32 action_id = 3;
inline bool REQAction::has_action_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQAction::set_has_action_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQAction::clear_has_action_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQAction::clear_action_id() {
  action_id_ = 0;
  clear_has_action_id();
}
inline ::google::protobuf::int32 REQAction::action_id() const {
  return action_id_;
}
inline void REQAction::set_action_id(::google::protobuf::int32 value) {
  set_has_action_id();
  action_id_ = value;
}

// optional int32 action_board_row = 4;
inline bool REQAction::has_action_board_row() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void REQAction::set_has_action_board_row() {
  _has_bits_[0] |= 0x00000008u;
}
inline void REQAction::clear_has_action_board_row() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void REQAction::clear_action_board_row() {
  action_board_row_ = 0;
  clear_has_action_board_row();
}
inline ::google::protobuf::int32 REQAction::action_board_row() const {
  return action_board_row_;
}
inline void REQAction::set_action_board_row(::google::protobuf::int32 value) {
  set_has_action_board_row();
  action_board_row_ = value;
}

// optional int32 action_board_col = 5;
inline bool REQAction::has_action_board_col() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void REQAction::set_has_action_board_col() {
  _has_bits_[0] |= 0x00000010u;
}
inline void REQAction::clear_has_action_board_col() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void REQAction::clear_action_board_col() {
  action_board_col_ = 0;
  clear_has_action_board_col();
}
inline ::google::protobuf::int32 REQAction::action_board_col() const {
  return action_board_col_;
}
inline void REQAction::set_action_board_col(::google::protobuf::int32 value) {
  set_has_action_board_col();
  action_board_col_ = value;
}

// optional int32 remain_time = 6;
inline bool REQAction::has_remain_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void REQAction::set_has_remain_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void REQAction::clear_has_remain_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void REQAction::clear_remain_time() {
  remain_time_ = 0;
  clear_has_remain_time();
}
inline ::google::protobuf::int32 REQAction::remain_time() const {
  return remain_time_;
}
inline void REQAction::set_remain_time(::google::protobuf::int32 value) {
  set_has_remain_time();
  remain_time_ = value;
}

// -------------------------------------------------------------------

// ACKAction

// required bytes result_msg = 1;
inline bool ACKAction::has_result_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKAction::set_has_result_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKAction::clear_has_result_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKAction::clear_result_msg() {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    result_msg_->clear();
  }
  clear_has_result_msg();
}
inline const ::std::string& ACKAction::result_msg() const {
  return *result_msg_;
}
inline void ACKAction::set_result_msg(const ::std::string& value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKAction::set_result_msg(const char* value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKAction::set_result_msg(const void* value, size_t size) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKAction::mutable_result_msg() {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  return result_msg_;
}
inline ::std::string* ACKAction::release_result_msg() {
  clear_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_msg_;
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKAction::set_allocated_result_msg(::std::string* result_msg) {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete result_msg_;
  }
  if (result_msg) {
    set_has_result_msg();
    result_msg_ = result_msg;
  } else {
    clear_has_result_msg();
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 action_id = 2;
inline bool ACKAction::has_action_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKAction::set_has_action_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKAction::clear_has_action_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKAction::clear_action_id() {
  action_id_ = 0;
  clear_has_action_id();
}
inline ::google::protobuf::int32 ACKAction::action_id() const {
  return action_id_;
}
inline void ACKAction::set_action_id(::google::protobuf::int32 value) {
  set_has_action_id();
  action_id_ = value;
}

// optional int32 action_board_row = 3;
inline bool ACKAction::has_action_board_row() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKAction::set_has_action_board_row() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKAction::clear_has_action_board_row() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKAction::clear_action_board_row() {
  action_board_row_ = 0;
  clear_has_action_board_row();
}
inline ::google::protobuf::int32 ACKAction::action_board_row() const {
  return action_board_row_;
}
inline void ACKAction::set_action_board_row(::google::protobuf::int32 value) {
  set_has_action_board_row();
  action_board_row_ = value;
}

// optional int32 action_board_col = 4;
inline bool ACKAction::has_action_board_col() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACKAction::set_has_action_board_col() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACKAction::clear_has_action_board_col() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACKAction::clear_action_board_col() {
  action_board_col_ = 0;
  clear_has_action_board_col();
}
inline ::google::protobuf::int32 ACKAction::action_board_col() const {
  return action_board_col_;
}
inline void ACKAction::set_action_board_col(::google::protobuf::int32 value) {
  set_has_action_board_col();
  action_board_col_ = value;
}

// optional bool is_win = 5;
inline bool ACKAction::has_is_win() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ACKAction::set_has_is_win() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ACKAction::clear_has_is_win() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ACKAction::clear_is_win() {
  is_win_ = false;
  clear_has_is_win();
}
inline bool ACKAction::is_win() const {
  return is_win_;
}
inline void ACKAction::set_is_win(bool value) {
  set_has_is_win();
  is_win_ = value;
}

// optional int32 win_id = 6;
inline bool ACKAction::has_win_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ACKAction::set_has_win_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ACKAction::clear_has_win_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ACKAction::clear_win_id() {
  win_id_ = 0;
  clear_has_win_id();
}
inline ::google::protobuf::int32 ACKAction::win_id() const {
  return win_id_;
}
inline void ACKAction::set_win_id(::google::protobuf::int32 value) {
  set_has_win_id();
  win_id_ = value;
}

// optional int32 lose_id = 7;
inline bool ACKAction::has_lose_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ACKAction::set_has_lose_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ACKAction::clear_has_lose_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ACKAction::clear_lose_id() {
  lose_id_ = 0;
  clear_has_lose_id();
}
inline ::google::protobuf::int32 ACKAction::lose_id() const {
  return lose_id_;
}
inline void ACKAction::set_lose_id(::google::protobuf::int32 value) {
  set_has_lose_id();
  lose_id_ = value;
}

// optional bytes win_msg = 8;
inline bool ACKAction::has_win_msg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ACKAction::set_has_win_msg() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ACKAction::clear_has_win_msg() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ACKAction::clear_win_msg() {
  if (win_msg_ != &::google::protobuf::internal::kEmptyString) {
    win_msg_->clear();
  }
  clear_has_win_msg();
}
inline const ::std::string& ACKAction::win_msg() const {
  return *win_msg_;
}
inline void ACKAction::set_win_msg(const ::std::string& value) {
  set_has_win_msg();
  if (win_msg_ == &::google::protobuf::internal::kEmptyString) {
    win_msg_ = new ::std::string;
  }
  win_msg_->assign(value);
}
inline void ACKAction::set_win_msg(const char* value) {
  set_has_win_msg();
  if (win_msg_ == &::google::protobuf::internal::kEmptyString) {
    win_msg_ = new ::std::string;
  }
  win_msg_->assign(value);
}
inline void ACKAction::set_win_msg(const void* value, size_t size) {
  set_has_win_msg();
  if (win_msg_ == &::google::protobuf::internal::kEmptyString) {
    win_msg_ = new ::std::string;
  }
  win_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKAction::mutable_win_msg() {
  set_has_win_msg();
  if (win_msg_ == &::google::protobuf::internal::kEmptyString) {
    win_msg_ = new ::std::string;
  }
  return win_msg_;
}
inline ::std::string* ACKAction::release_win_msg() {
  clear_has_win_msg();
  if (win_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = win_msg_;
    win_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKAction::set_allocated_win_msg(::std::string* win_msg) {
  if (win_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete win_msg_;
  }
  if (win_msg) {
    set_has_win_msg();
    win_msg_ = win_msg;
  } else {
    clear_has_win_msg();
    win_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Position

// required int32 row = 1;
inline bool Position::has_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_row() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_row() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_row() {
  row_ = 0;
  clear_has_row();
}
inline ::google::protobuf::int32 Position::row() const {
  return row_;
}
inline void Position::set_row(::google::protobuf::int32 value) {
  set_has_row();
  row_ = value;
}

// required int32 col = 2;
inline bool Position::has_col() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_col() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_col() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_col() {
  col_ = 0;
  clear_has_col();
}
inline ::google::protobuf::int32 Position::col() const {
  return col_;
}
inline void Position::set_col(::google::protobuf::int32 value) {
  set_has_col();
  col_ = value;
}

// -------------------------------------------------------------------

// REQGameOver

// optional int32 winner_id = 1;
inline bool REQGameOver::has_winner_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQGameOver::set_has_winner_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQGameOver::clear_has_winner_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQGameOver::clear_winner_id() {
  winner_id_ = 0;
  clear_has_winner_id();
}
inline ::google::protobuf::int32 REQGameOver::winner_id() const {
  return winner_id_;
}
inline void REQGameOver::set_winner_id(::google::protobuf::int32 value) {
  set_has_winner_id();
  winner_id_ = value;
}

// optional int32 loser_id = 2;
inline bool REQGameOver::has_loser_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQGameOver::set_has_loser_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQGameOver::clear_has_loser_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQGameOver::clear_loser_id() {
  loser_id_ = 0;
  clear_has_loser_id();
}
inline ::google::protobuf::int32 REQGameOver::loser_id() const {
  return loser_id_;
}
inline void REQGameOver::set_loser_id(::google::protobuf::int32 value) {
  set_has_loser_id();
  loser_id_ = value;
}

// optional int32 score = 3;
inline bool REQGameOver::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQGameOver::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQGameOver::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQGameOver::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 REQGameOver::score() const {
  return score_;
}
inline void REQGameOver::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// required int32 black_id = 4;
inline bool REQGameOver::has_black_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void REQGameOver::set_has_black_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void REQGameOver::clear_has_black_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void REQGameOver::clear_black_id() {
  black_id_ = 0;
  clear_has_black_id();
}
inline ::google::protobuf::int32 REQGameOver::black_id() const {
  return black_id_;
}
inline void REQGameOver::set_black_id(::google::protobuf::int32 value) {
  set_has_black_id();
  black_id_ = value;
}

// required int32 white_id = 5;
inline bool REQGameOver::has_white_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void REQGameOver::set_has_white_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void REQGameOver::clear_has_white_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void REQGameOver::clear_white_id() {
  white_id_ = 0;
  clear_has_white_id();
}
inline ::google::protobuf::int32 REQGameOver::white_id() const {
  return white_id_;
}
inline void REQGameOver::set_white_id(::google::protobuf::int32 value) {
  set_has_white_id();
  white_id_ = value;
}

// required bool is_no_winner = 6;
inline bool REQGameOver::has_is_no_winner() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void REQGameOver::set_has_is_no_winner() {
  _has_bits_[0] |= 0x00000020u;
}
inline void REQGameOver::clear_has_is_no_winner() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void REQGameOver::clear_is_no_winner() {
  is_no_winner_ = false;
  clear_has_is_no_winner();
}
inline bool REQGameOver::is_no_winner() const {
  return is_no_winner_;
}
inline void REQGameOver::set_is_no_winner(bool value) {
  set_has_is_no_winner();
  is_no_winner_ = value;
}

// required bool is_force_exit = 7;
inline bool REQGameOver::has_is_force_exit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void REQGameOver::set_has_is_force_exit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void REQGameOver::clear_has_is_force_exit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void REQGameOver::clear_is_force_exit() {
  is_force_exit_ = false;
  clear_has_is_force_exit();
}
inline bool REQGameOver::is_force_exit() const {
  return is_force_exit_;
}
inline void REQGameOver::set_is_force_exit(bool value) {
  set_has_is_force_exit();
  is_force_exit_ = value;
}

// repeated .Position black_positions = 8;
inline int REQGameOver::black_positions_size() const {
  return black_positions_.size();
}
inline void REQGameOver::clear_black_positions() {
  black_positions_.Clear();
}
inline const ::Position& REQGameOver::black_positions(int index) const {
  return black_positions_.Get(index);
}
inline ::Position* REQGameOver::mutable_black_positions(int index) {
  return black_positions_.Mutable(index);
}
inline ::Position* REQGameOver::add_black_positions() {
  return black_positions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Position >&
REQGameOver::black_positions() const {
  return black_positions_;
}
inline ::google::protobuf::RepeatedPtrField< ::Position >*
REQGameOver::mutable_black_positions() {
  return &black_positions_;
}

// repeated .Position white_positions = 9;
inline int REQGameOver::white_positions_size() const {
  return white_positions_.size();
}
inline void REQGameOver::clear_white_positions() {
  white_positions_.Clear();
}
inline const ::Position& REQGameOver::white_positions(int index) const {
  return white_positions_.Get(index);
}
inline ::Position* REQGameOver::mutable_white_positions(int index) {
  return white_positions_.Mutable(index);
}
inline ::Position* REQGameOver::add_white_positions() {
  return white_positions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Position >&
REQGameOver::white_positions() const {
  return white_positions_;
}
inline ::google::protobuf::RepeatedPtrField< ::Position >*
REQGameOver::mutable_white_positions() {
  return &white_positions_;
}

// required int32 conis = 10;
inline bool REQGameOver::has_conis() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void REQGameOver::set_has_conis() {
  _has_bits_[0] |= 0x00000200u;
}
inline void REQGameOver::clear_has_conis() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void REQGameOver::clear_conis() {
  conis_ = 0;
  clear_has_conis();
}
inline ::google::protobuf::int32 REQGameOver::conis() const {
  return conis_;
}
inline void REQGameOver::set_conis(::google::protobuf::int32 value) {
  set_has_conis();
  conis_ = value;
}

// -------------------------------------------------------------------

// REQExitGame

// required bytes req_msg = 1;
inline bool REQExitGame::has_req_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQExitGame::set_has_req_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQExitGame::clear_has_req_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQExitGame::clear_req_msg() {
  if (req_msg_ != &::google::protobuf::internal::kEmptyString) {
    req_msg_->clear();
  }
  clear_has_req_msg();
}
inline const ::std::string& REQExitGame::req_msg() const {
  return *req_msg_;
}
inline void REQExitGame::set_req_msg(const ::std::string& value) {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  req_msg_->assign(value);
}
inline void REQExitGame::set_req_msg(const char* value) {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  req_msg_->assign(value);
}
inline void REQExitGame::set_req_msg(const void* value, size_t size) {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  req_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQExitGame::mutable_req_msg() {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  return req_msg_;
}
inline ::std::string* REQExitGame::release_req_msg() {
  clear_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = req_msg_;
    req_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void REQExitGame::set_allocated_req_msg(::std::string* req_msg) {
  if (req_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete req_msg_;
  }
  if (req_msg) {
    set_has_req_msg();
    req_msg_ = req_msg;
  } else {
    clear_has_req_msg();
    req_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 exit_table_id = 2;
inline bool REQExitGame::has_exit_table_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQExitGame::set_has_exit_table_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQExitGame::clear_has_exit_table_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQExitGame::clear_exit_table_id() {
  exit_table_id_ = 0;
  clear_has_exit_table_id();
}
inline ::google::protobuf::int32 REQExitGame::exit_table_id() const {
  return exit_table_id_;
}
inline void REQExitGame::set_exit_table_id(::google::protobuf::int32 value) {
  set_has_exit_table_id();
  exit_table_id_ = value;
}

// required int32 exit_user_id = 3;
inline bool REQExitGame::has_exit_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQExitGame::set_has_exit_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQExitGame::clear_has_exit_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQExitGame::clear_exit_user_id() {
  exit_user_id_ = 0;
  clear_has_exit_user_id();
}
inline ::google::protobuf::int32 REQExitGame::exit_user_id() const {
  return exit_user_id_;
}
inline void REQExitGame::set_exit_user_id(::google::protobuf::int32 value) {
  set_has_exit_user_id();
  exit_user_id_ = value;
}

// required int32 enemy_user_id = 4;
inline bool REQExitGame::has_enemy_user_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void REQExitGame::set_has_enemy_user_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void REQExitGame::clear_has_enemy_user_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void REQExitGame::clear_enemy_user_id() {
  enemy_user_id_ = 0;
  clear_has_enemy_user_id();
}
inline ::google::protobuf::int32 REQExitGame::enemy_user_id() const {
  return enemy_user_id_;
}
inline void REQExitGame::set_enemy_user_id(::google::protobuf::int32 value) {
  set_has_enemy_user_id();
  enemy_user_id_ = value;
}

// -------------------------------------------------------------------

// ACKExitGame

// required int32 code = 1;
inline bool ACKExitGame::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKExitGame::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKExitGame::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKExitGame::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKExitGame::code() const {
  return code_;
}
inline void ACKExitGame::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required bytes result_msg = 2;
inline bool ACKExitGame::has_result_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKExitGame::set_has_result_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKExitGame::clear_has_result_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKExitGame::clear_result_msg() {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    result_msg_->clear();
  }
  clear_has_result_msg();
}
inline const ::std::string& ACKExitGame::result_msg() const {
  return *result_msg_;
}
inline void ACKExitGame::set_result_msg(const ::std::string& value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKExitGame::set_result_msg(const char* value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKExitGame::set_result_msg(const void* value, size_t size) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKExitGame::mutable_result_msg() {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  return result_msg_;
}
inline ::std::string* ACKExitGame::release_result_msg() {
  clear_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_msg_;
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKExitGame::set_allocated_result_msg(::std::string* result_msg) {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete result_msg_;
  }
  if (result_msg) {
    set_has_result_msg();
    result_msg_ = result_msg;
  } else {
    clear_has_result_msg();
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 exit_table_id = 3;
inline bool ACKExitGame::has_exit_table_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKExitGame::set_has_exit_table_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKExitGame::clear_has_exit_table_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKExitGame::clear_exit_table_id() {
  exit_table_id_ = 0;
  clear_has_exit_table_id();
}
inline ::google::protobuf::int32 ACKExitGame::exit_table_id() const {
  return exit_table_id_;
}
inline void ACKExitGame::set_exit_table_id(::google::protobuf::int32 value) {
  set_has_exit_table_id();
  exit_table_id_ = value;
}

// optional int32 exit_user_id = 4;
inline bool ACKExitGame::has_exit_user_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACKExitGame::set_has_exit_user_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACKExitGame::clear_has_exit_user_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACKExitGame::clear_exit_user_id() {
  exit_user_id_ = 0;
  clear_has_exit_user_id();
}
inline ::google::protobuf::int32 ACKExitGame::exit_user_id() const {
  return exit_user_id_;
}
inline void ACKExitGame::set_exit_user_id(::google::protobuf::int32 value) {
  set_has_exit_user_id();
  exit_user_id_ = value;
}

// -------------------------------------------------------------------

// REQForcExit

// optional int32 user_id = 1;
inline bool REQForcExit::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQForcExit::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQForcExit::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQForcExit::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQForcExit::user_id() const {
  return user_id_;
}
inline void REQForcExit::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// REQAskUndoChess

// required int32 table_id = 1;
inline bool REQAskUndoChess::has_table_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQAskUndoChess::set_has_table_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQAskUndoChess::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQAskUndoChess::clear_table_id() {
  table_id_ = 0;
  clear_has_table_id();
}
inline ::google::protobuf::int32 REQAskUndoChess::table_id() const {
  return table_id_;
}
inline void REQAskUndoChess::set_table_id(::google::protobuf::int32 value) {
  set_has_table_id();
  table_id_ = value;
}

// required int32 action_id = 2;
inline bool REQAskUndoChess::has_action_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQAskUndoChess::set_has_action_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQAskUndoChess::clear_has_action_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQAskUndoChess::clear_action_id() {
  action_id_ = 0;
  clear_has_action_id();
}
inline ::google::protobuf::int32 REQAskUndoChess::action_id() const {
  return action_id_;
}
inline void REQAskUndoChess::set_action_id(::google::protobuf::int32 value) {
  set_has_action_id();
  action_id_ = value;
}

// -------------------------------------------------------------------

// ACKAskUndoChess

// required bool is_agree_undo_chess = 1;
inline bool ACKAskUndoChess::has_is_agree_undo_chess() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKAskUndoChess::set_has_is_agree_undo_chess() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKAskUndoChess::clear_has_is_agree_undo_chess() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKAskUndoChess::clear_is_agree_undo_chess() {
  is_agree_undo_chess_ = false;
  clear_has_is_agree_undo_chess();
}
inline bool ACKAskUndoChess::is_agree_undo_chess() const {
  return is_agree_undo_chess_;
}
inline void ACKAskUndoChess::set_is_agree_undo_chess(bool value) {
  set_has_is_agree_undo_chess();
  is_agree_undo_chess_ = value;
}

// required int32 table_id = 2;
inline bool ACKAskUndoChess::has_table_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKAskUndoChess::set_has_table_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKAskUndoChess::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKAskUndoChess::clear_table_id() {
  table_id_ = 0;
  clear_has_table_id();
}
inline ::google::protobuf::int32 ACKAskUndoChess::table_id() const {
  return table_id_;
}
inline void ACKAskUndoChess::set_table_id(::google::protobuf::int32 value) {
  set_has_table_id();
  table_id_ = value;
}

// required int32 action_id = 3;
inline bool ACKAskUndoChess::has_action_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKAskUndoChess::set_has_action_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKAskUndoChess::clear_has_action_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKAskUndoChess::clear_action_id() {
  action_id_ = 0;
  clear_has_action_id();
}
inline ::google::protobuf::int32 ACKAskUndoChess::action_id() const {
  return action_id_;
}
inline void ACKAskUndoChess::set_action_id(::google::protobuf::int32 value) {
  set_has_action_id();
  action_id_ = value;
}

// -------------------------------------------------------------------

// REQChat

// required int32 user_id = 1;
inline bool REQChat::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQChat::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQChat::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQChat::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQChat::user_id() const {
  return user_id_;
}
inline void REQChat::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 table_id = 2;
inline bool REQChat::has_table_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQChat::set_has_table_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQChat::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQChat::clear_table_id() {
  table_id_ = 0;
  clear_has_table_id();
}
inline ::google::protobuf::int32 REQChat::table_id() const {
  return table_id_;
}
inline void REQChat::set_table_id(::google::protobuf::int32 value) {
  set_has_table_id();
  table_id_ = value;
}

// required int32 opp_id = 3;
inline bool REQChat::has_opp_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQChat::set_has_opp_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQChat::clear_has_opp_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQChat::clear_opp_id() {
  opp_id_ = 0;
  clear_has_opp_id();
}
inline ::google::protobuf::int32 REQChat::opp_id() const {
  return opp_id_;
}
inline void REQChat::set_opp_id(::google::protobuf::int32 value) {
  set_has_opp_id();
  opp_id_ = value;
}

// optional bytes text = 4;
inline bool REQChat::has_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void REQChat::set_has_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void REQChat::clear_has_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void REQChat::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& REQChat::text() const {
  return *text_;
}
inline void REQChat::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void REQChat::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void REQChat::set_text(const void* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQChat::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* REQChat::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void REQChat::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ACKChatText

// required int32 is_sensitive = 1;
inline bool ACKChatText::has_is_sensitive() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKChatText::set_has_is_sensitive() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKChatText::clear_has_is_sensitive() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKChatText::clear_is_sensitive() {
  is_sensitive_ = 0;
  clear_has_is_sensitive();
}
inline ::google::protobuf::int32 ACKChatText::is_sensitive() const {
  return is_sensitive_;
}
inline void ACKChatText::set_is_sensitive(::google::protobuf::int32 value) {
  set_has_is_sensitive();
  is_sensitive_ = value;
}

// required int32 user_id = 2;
inline bool ACKChatText::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKChatText::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKChatText::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKChatText::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 ACKChatText::user_id() const {
  return user_id_;
}
inline void ACKChatText::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 table_id = 3;
inline bool ACKChatText::has_table_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKChatText::set_has_table_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKChatText::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKChatText::clear_table_id() {
  table_id_ = 0;
  clear_has_table_id();
}
inline ::google::protobuf::int32 ACKChatText::table_id() const {
  return table_id_;
}
inline void ACKChatText::set_table_id(::google::protobuf::int32 value) {
  set_has_table_id();
  table_id_ = value;
}

// required int32 opp_id = 4;
inline bool ACKChatText::has_opp_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACKChatText::set_has_opp_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACKChatText::clear_has_opp_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACKChatText::clear_opp_id() {
  opp_id_ = 0;
  clear_has_opp_id();
}
inline ::google::protobuf::int32 ACKChatText::opp_id() const {
  return opp_id_;
}
inline void ACKChatText::set_opp_id(::google::protobuf::int32 value) {
  set_has_opp_id();
  opp_id_ = value;
}

// optional bytes text = 5;
inline bool ACKChatText::has_text() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ACKChatText::set_has_text() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ACKChatText::clear_has_text() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ACKChatText::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& ACKChatText::text() const {
  return *text_;
}
inline void ACKChatText::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ACKChatText::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ACKChatText::set_text(const void* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKChatText::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* ACKChatText::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKChatText::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// REQContinueGame

// required int32 user_id = 1;
inline bool REQContinueGame::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQContinueGame::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQContinueGame::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQContinueGame::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQContinueGame::user_id() const {
  return user_id_;
}
inline void REQContinueGame::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 enemy_user_id = 2;
inline bool REQContinueGame::has_enemy_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQContinueGame::set_has_enemy_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQContinueGame::clear_has_enemy_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQContinueGame::clear_enemy_user_id() {
  enemy_user_id_ = 0;
  clear_has_enemy_user_id();
}
inline ::google::protobuf::int32 REQContinueGame::enemy_user_id() const {
  return enemy_user_id_;
}
inline void REQContinueGame::set_enemy_user_id(::google::protobuf::int32 value) {
  set_has_enemy_user_id();
  enemy_user_id_ = value;
}

// required int32 table_id = 3;
inline bool REQContinueGame::has_table_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQContinueGame::set_has_table_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQContinueGame::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQContinueGame::clear_table_id() {
  table_id_ = 0;
  clear_has_table_id();
}
inline ::google::protobuf::int32 REQContinueGame::table_id() const {
  return table_id_;
}
inline void REQContinueGame::set_table_id(::google::protobuf::int32 value) {
  set_has_table_id();
  table_id_ = value;
}

// -------------------------------------------------------------------

// ACKContinueGame

// required int32 code = 1;
inline bool ACKContinueGame::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKContinueGame::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKContinueGame::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKContinueGame::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKContinueGame::code() const {
  return code_;
}
inline void ACKContinueGame::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required bytes result_msg = 2;
inline bool ACKContinueGame::has_result_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKContinueGame::set_has_result_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKContinueGame::clear_has_result_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKContinueGame::clear_result_msg() {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    result_msg_->clear();
  }
  clear_has_result_msg();
}
inline const ::std::string& ACKContinueGame::result_msg() const {
  return *result_msg_;
}
inline void ACKContinueGame::set_result_msg(const ::std::string& value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKContinueGame::set_result_msg(const char* value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKContinueGame::set_result_msg(const void* value, size_t size) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKContinueGame::mutable_result_msg() {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  return result_msg_;
}
inline ::std::string* ACKContinueGame::release_result_msg() {
  clear_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_msg_;
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKContinueGame::set_allocated_result_msg(::std::string* result_msg) {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete result_msg_;
  }
  if (result_msg) {
    set_has_result_msg();
    result_msg_ = result_msg;
  } else {
    clear_has_result_msg();
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// REQAskContinueGame

// required int32 enemy_user_id = 1;
inline bool REQAskContinueGame::has_enemy_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQAskContinueGame::set_has_enemy_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQAskContinueGame::clear_has_enemy_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQAskContinueGame::clear_enemy_user_id() {
  enemy_user_id_ = 0;
  clear_has_enemy_user_id();
}
inline ::google::protobuf::int32 REQAskContinueGame::enemy_user_id() const {
  return enemy_user_id_;
}
inline void REQAskContinueGame::set_enemy_user_id(::google::protobuf::int32 value) {
  set_has_enemy_user_id();
  enemy_user_id_ = value;
}

// required int32 user_id = 2;
inline bool REQAskContinueGame::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQAskContinueGame::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQAskContinueGame::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQAskContinueGame::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQAskContinueGame::user_id() const {
  return user_id_;
}
inline void REQAskContinueGame::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 table_id = 3;
inline bool REQAskContinueGame::has_table_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQAskContinueGame::set_has_table_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQAskContinueGame::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQAskContinueGame::clear_table_id() {
  table_id_ = 0;
  clear_has_table_id();
}
inline ::google::protobuf::int32 REQAskContinueGame::table_id() const {
  return table_id_;
}
inline void REQAskContinueGame::set_table_id(::google::protobuf::int32 value) {
  set_has_table_id();
  table_id_ = value;
}

// -------------------------------------------------------------------

// ACKAskContinueGame

// required bool is_agree_continue_game = 1;
inline bool ACKAskContinueGame::has_is_agree_continue_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKAskContinueGame::set_has_is_agree_continue_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKAskContinueGame::clear_has_is_agree_continue_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKAskContinueGame::clear_is_agree_continue_game() {
  is_agree_continue_game_ = false;
  clear_has_is_agree_continue_game();
}
inline bool ACKAskContinueGame::is_agree_continue_game() const {
  return is_agree_continue_game_;
}
inline void ACKAskContinueGame::set_is_agree_continue_game(bool value) {
  set_has_is_agree_continue_game();
  is_agree_continue_game_ = value;
}

// required int32 enemy_user_id = 2;
inline bool ACKAskContinueGame::has_enemy_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKAskContinueGame::set_has_enemy_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKAskContinueGame::clear_has_enemy_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKAskContinueGame::clear_enemy_user_id() {
  enemy_user_id_ = 0;
  clear_has_enemy_user_id();
}
inline ::google::protobuf::int32 ACKAskContinueGame::enemy_user_id() const {
  return enemy_user_id_;
}
inline void ACKAskContinueGame::set_enemy_user_id(::google::protobuf::int32 value) {
  set_has_enemy_user_id();
  enemy_user_id_ = value;
}

// required int32 user_id = 3;
inline bool ACKAskContinueGame::has_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKAskContinueGame::set_has_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKAskContinueGame::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKAskContinueGame::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 ACKAskContinueGame::user_id() const {
  return user_id_;
}
inline void ACKAskContinueGame::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 table_id = 4;
inline bool ACKAskContinueGame::has_table_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACKAskContinueGame::set_has_table_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACKAskContinueGame::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACKAskContinueGame::clear_table_id() {
  table_id_ = 0;
  clear_has_table_id();
}
inline ::google::protobuf::int32 ACKAskContinueGame::table_id() const {
  return table_id_;
}
inline void ACKAskContinueGame::set_table_id(::google::protobuf::int32 value) {
  set_has_table_id();
  table_id_ = value;
}

// -------------------------------------------------------------------

// ACKRefuseContinueGame

// required int32 code = 1;
inline bool ACKRefuseContinueGame::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKRefuseContinueGame::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKRefuseContinueGame::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKRefuseContinueGame::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKRefuseContinueGame::code() const {
  return code_;
}
inline void ACKRefuseContinueGame::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required bytes result_msg = 2;
inline bool ACKRefuseContinueGame::has_result_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKRefuseContinueGame::set_has_result_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKRefuseContinueGame::clear_has_result_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKRefuseContinueGame::clear_result_msg() {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    result_msg_->clear();
  }
  clear_has_result_msg();
}
inline const ::std::string& ACKRefuseContinueGame::result_msg() const {
  return *result_msg_;
}
inline void ACKRefuseContinueGame::set_result_msg(const ::std::string& value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKRefuseContinueGame::set_result_msg(const char* value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKRefuseContinueGame::set_result_msg(const void* value, size_t size) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKRefuseContinueGame::mutable_result_msg() {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  return result_msg_;
}
inline ::std::string* ACKRefuseContinueGame::release_result_msg() {
  clear_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_msg_;
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKRefuseContinueGame::set_allocated_result_msg(::std::string* result_msg) {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete result_msg_;
  }
  if (result_msg) {
    set_has_result_msg();
    result_msg_ = result_msg;
  } else {
    clear_has_result_msg();
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gameProtocol_2eproto__INCLUDED
