// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: wzqProtocol.proto

#ifndef PROTOBUF_wzqProtocol_2eproto__INCLUDED
#define PROTOBUF_wzqProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_wzqProtocol_2eproto();
void protobuf_AssignDesc_wzqProtocol_2eproto();
void protobuf_ShutdownFile_wzqProtocol_2eproto();

class REQHold;
class ACKHold;
class MsgPackage;
class REQRegister;
class ACKRegister;
class REQLogin;
class ACKLogin;
class UserInfo;
class UserInfo_Prop;
class REQGetUserInfo;
class ACKGetUserInfo;
class REQEditHead;
class ACKEditHead;
class REQEditUserName;
class ACKEditUserName;
class REQGetRandingList;
class ACKGetRandingList;
class Position;
class REQGameOver;
class REQGetGameHistory;
class GameInfo;
class ACKGetGameHistory;
class REQGetFriendInfo;
class ACKGetFriendInfo;
class REQAddFriend;
class ACKAddFriend;
class REQRequestFriend;
class REQIsAgreeFriend;
class ACKIsAgreeFriend;
class ACKUpdateFriend;
class REQFriendsList;
class ACKFriendsList;
class REQWaitFriendsList;
class ACKWaitFriendsList;
class REQDeleteFriend;
class ACKDeleteFriend;
class REQBuy;
class ACKBuy;

// ===================================================================

class REQHold : public ::google::protobuf::Message {
 public:
  REQHold();
  virtual ~REQHold();

  REQHold(const REQHold& from);

  inline REQHold& operator=(const REQHold& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQHold& default_instance();

  void Swap(REQHold* other);

  // implements Message ----------------------------------------------

  REQHold* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQHold& from);
  void MergeFrom(const REQHold& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:REQHold)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQHold* default_instance_;
};
// -------------------------------------------------------------------

class ACKHold : public ::google::protobuf::Message {
 public:
  ACKHold();
  virtual ~ACKHold();

  ACKHold(const ACKHold& from);

  inline ACKHold& operator=(const ACKHold& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKHold& default_instance();

  void Swap(ACKHold* other);

  // implements Message ----------------------------------------------

  ACKHold* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKHold& from);
  void MergeFrom(const ACKHold& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result_id = 1;
  inline bool has_result_id() const;
  inline void clear_result_id();
  static const int kResultIdFieldNumber = 1;
  inline ::google::protobuf::int32 result_id() const;
  inline void set_result_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ACKHold)
 private:
  inline void set_has_result_id();
  inline void clear_has_result_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKHold* default_instance_;
};
// -------------------------------------------------------------------

class MsgPackage : public ::google::protobuf::Message {
 public:
  MsgPackage();
  virtual ~MsgPackage();

  MsgPackage(const MsgPackage& from);

  inline MsgPackage& operator=(const MsgPackage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPackage& default_instance();

  void Swap(MsgPackage* other);

  // implements Message ----------------------------------------------

  MsgPackage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPackage& from);
  void MergeFrom(const MsgPackage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 msg_id = 1;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  inline ::google::protobuf::int64 msg_id() const;
  inline void set_msg_id(::google::protobuf::int64 value);

  // optional int64 seq_id = 2;
  inline bool has_seq_id() const;
  inline void clear_seq_id();
  static const int kSeqIdFieldNumber = 2;
  inline ::google::protobuf::int64 seq_id() const;
  inline void set_seq_id(::google::protobuf::int64 value);

  // optional int64 user_id = 3;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // optional bytes msg = 4;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 4;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // optional bytes src = 5;
  inline bool has_src() const;
  inline void clear_src();
  static const int kSrcFieldNumber = 5;
  inline const ::std::string& src() const;
  inline void set_src(const ::std::string& value);
  inline void set_src(const char* value);
  inline void set_src(const void* value, size_t size);
  inline ::std::string* mutable_src();
  inline ::std::string* release_src();
  inline void set_allocated_src(::std::string* src);

  // optional int64 clientid = 6;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 6;
  inline ::google::protobuf::int64 clientid() const;
  inline void set_clientid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:MsgPackage)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_seq_id();
  inline void clear_has_seq_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_src();
  inline void clear_has_src();
  inline void set_has_clientid();
  inline void clear_has_clientid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 msg_id_;
  ::google::protobuf::int64 seq_id_;
  ::google::protobuf::int64 user_id_;
  ::std::string* msg_;
  ::std::string* src_;
  ::google::protobuf::int64 clientid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static MsgPackage* default_instance_;
};
// -------------------------------------------------------------------

class REQRegister : public ::google::protobuf::Message {
 public:
  REQRegister();
  virtual ~REQRegister();

  REQRegister(const REQRegister& from);

  inline REQRegister& operator=(const REQRegister& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQRegister& default_instance();

  void Swap(REQRegister* other);

  // implements Message ----------------------------------------------

  REQRegister* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQRegister& from);
  void MergeFrom(const REQRegister& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const void* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional bytes passwd = 2;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 2;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const void* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  inline void set_allocated_passwd(::std::string* passwd);

  // @@protoc_insertion_point(class_scope:REQRegister)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_passwd();
  inline void clear_has_passwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* passwd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQRegister* default_instance_;
};
// -------------------------------------------------------------------

class ACKRegister : public ::google::protobuf::Message {
 public:
  ACKRegister();
  virtual ~ACKRegister();

  ACKRegister(const ACKRegister& from);

  inline ACKRegister& operator=(const ACKRegister& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKRegister& default_instance();

  void Swap(ACKRegister* other);

  // implements Message ----------------------------------------------

  ACKRegister* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKRegister& from);
  void MergeFrom(const ACKRegister& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional bytes result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  inline ::std::string* release_result();
  inline void set_allocated_result(::std::string* result);

  // @@protoc_insertion_point(class_scope:ACKRegister)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKRegister* default_instance_;
};
// -------------------------------------------------------------------

class REQLogin : public ::google::protobuf::Message {
 public:
  REQLogin();
  virtual ~REQLogin();

  REQLogin(const REQLogin& from);

  inline REQLogin& operator=(const REQLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQLogin& default_instance();

  void Swap(REQLogin* other);

  // implements Message ----------------------------------------------

  REQLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQLogin& from);
  void MergeFrom(const REQLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const void* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional bytes passwd = 2;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 2;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const void* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  inline void set_allocated_passwd(::std::string* passwd);

  // @@protoc_insertion_point(class_scope:REQLogin)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_passwd();
  inline void clear_has_passwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* passwd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQLogin* default_instance_;
};
// -------------------------------------------------------------------

class ACKLogin : public ::google::protobuf::Message {
 public:
  ACKLogin();
  virtual ~ACKLogin();

  ACKLogin(const ACKLogin& from);

  inline ACKLogin& operator=(const ACKLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKLogin& default_instance();

  void Swap(ACKLogin* other);

  // implements Message ----------------------------------------------

  ACKLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKLogin& from);
  void MergeFrom(const ACKLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional .UserInfo userinfo = 2;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserinfoFieldNumber = 2;
  inline const ::UserInfo& userinfo() const;
  inline ::UserInfo* mutable_userinfo();
  inline ::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::UserInfo* userinfo);

  // @@protoc_insertion_point(class_scope:ACKLogin)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserInfo* userinfo_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKLogin* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo_Prop : public ::google::protobuf::Message {
 public:
  UserInfo_Prop();
  virtual ~UserInfo_Prop();

  UserInfo_Prop(const UserInfo_Prop& from);

  inline UserInfo_Prop& operator=(const UserInfo_Prop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo_Prop& default_instance();

  void Swap(UserInfo_Prop* other);

  // implements Message ----------------------------------------------

  UserInfo_Prop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo_Prop& from);
  void MergeFrom(const UserInfo_Prop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 quantity = 2;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  inline ::google::protobuf::int32 quantity() const;
  inline void set_quantity(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UserInfo.Prop)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_quantity();
  inline void clear_has_quantity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 quantity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static UserInfo_Prop* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UserInfo_Prop Prop;

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional bytes username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const void* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional int32 wintimes = 3;
  inline bool has_wintimes() const;
  inline void clear_wintimes();
  static const int kWintimesFieldNumber = 3;
  inline ::google::protobuf::int32 wintimes() const;
  inline void set_wintimes(::google::protobuf::int32 value);

  // optional int32 losetimes = 4;
  inline bool has_losetimes() const;
  inline void clear_losetimes();
  static const int kLosetimesFieldNumber = 4;
  inline ::google::protobuf::int32 losetimes() const;
  inline void set_losetimes(::google::protobuf::int32 value);

  // optional int32 score = 5;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 5;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // optional int32 level = 6;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 6;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 xp = 7;
  inline bool has_xp() const;
  inline void clear_xp();
  static const int kXpFieldNumber = 7;
  inline ::google::protobuf::int32 xp() const;
  inline void set_xp(::google::protobuf::int32 value);

  // optional int32 head_id = 8;
  inline bool has_head_id() const;
  inline void clear_head_id();
  static const int kHeadIdFieldNumber = 8;
  inline ::google::protobuf::int32 head_id() const;
  inline void set_head_id(::google::protobuf::int32 value);

  // optional bool is_online = 9;
  inline bool has_is_online() const;
  inline void clear_is_online();
  static const int kIsOnlineFieldNumber = 9;
  inline bool is_online() const;
  inline void set_is_online(bool value);

  // optional int32 coins = 10;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 10;
  inline ::google::protobuf::int32 coins() const;
  inline void set_coins(::google::protobuf::int32 value);

  // repeated .UserInfo.Prop props = 11;
  inline int props_size() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 11;
  inline const ::UserInfo_Prop& props(int index) const;
  inline ::UserInfo_Prop* mutable_props(int index);
  inline ::UserInfo_Prop* add_props();
  inline const ::google::protobuf::RepeatedPtrField< ::UserInfo_Prop >&
      props() const;
  inline ::google::protobuf::RepeatedPtrField< ::UserInfo_Prop >*
      mutable_props();

  // optional bytes account = 12;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 12;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const void* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // @@protoc_insertion_point(class_scope:UserInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_wintimes();
  inline void clear_has_wintimes();
  inline void set_has_losetimes();
  inline void clear_has_losetimes();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_xp();
  inline void clear_has_xp();
  inline void set_has_head_id();
  inline void clear_has_head_id();
  inline void set_has_is_online();
  inline void clear_has_is_online();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 wintimes_;
  ::google::protobuf::int32 losetimes_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 xp_;
  ::google::protobuf::int32 head_id_;
  bool is_online_;
  ::google::protobuf::RepeatedPtrField< ::UserInfo_Prop > props_;
  ::std::string* account_;
  ::google::protobuf::int32 coins_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class REQGetUserInfo : public ::google::protobuf::Message {
 public:
  REQGetUserInfo();
  virtual ~REQGetUserInfo();

  REQGetUserInfo(const REQGetUserInfo& from);

  inline REQGetUserInfo& operator=(const REQGetUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQGetUserInfo& default_instance();

  void Swap(REQGetUserInfo* other);

  // implements Message ----------------------------------------------

  REQGetUserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQGetUserInfo& from);
  void MergeFrom(const REQGetUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQGetUserInfo)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQGetUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class ACKGetUserInfo : public ::google::protobuf::Message {
 public:
  ACKGetUserInfo();
  virtual ~ACKGetUserInfo();

  ACKGetUserInfo(const ACKGetUserInfo& from);

  inline ACKGetUserInfo& operator=(const ACKGetUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKGetUserInfo& default_instance();

  void Swap(ACKGetUserInfo* other);

  // implements Message ----------------------------------------------

  ACKGetUserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKGetUserInfo& from);
  void MergeFrom(const ACKGetUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result_id = 1;
  inline bool has_result_id() const;
  inline void clear_result_id();
  static const int kResultIdFieldNumber = 1;
  inline ::google::protobuf::int32 result_id() const;
  inline void set_result_id(::google::protobuf::int32 value);

  // required .UserInfo userinfo = 2;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserinfoFieldNumber = 2;
  inline const ::UserInfo& userinfo() const;
  inline ::UserInfo* mutable_userinfo();
  inline ::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::UserInfo* userinfo);

  // @@protoc_insertion_point(class_scope:ACKGetUserInfo)
 private:
  inline void set_has_result_id();
  inline void clear_has_result_id();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserInfo* userinfo_;
  ::google::protobuf::int32 result_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKGetUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class REQEditHead : public ::google::protobuf::Message {
 public:
  REQEditHead();
  virtual ~REQEditHead();

  REQEditHead(const REQEditHead& from);

  inline REQEditHead& operator=(const REQEditHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQEditHead& default_instance();

  void Swap(REQEditHead* other);

  // implements Message ----------------------------------------------

  REQEditHead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQEditHead& from);
  void MergeFrom(const REQEditHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 head_num = 1;
  inline bool has_head_num() const;
  inline void clear_head_num();
  static const int kHeadNumFieldNumber = 1;
  inline ::google::protobuf::int32 head_num() const;
  inline void set_head_num(::google::protobuf::int32 value);

  // optional int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQEditHead)
 private:
  inline void set_has_head_num();
  inline void clear_has_head_num();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 head_num_;
  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQEditHead* default_instance_;
};
// -------------------------------------------------------------------

class ACKEditHead : public ::google::protobuf::Message {
 public:
  ACKEditHead();
  virtual ~ACKEditHead();

  ACKEditHead(const ACKEditHead& from);

  inline ACKEditHead& operator=(const ACKEditHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKEditHead& default_instance();

  void Swap(ACKEditHead* other);

  // implements Message ----------------------------------------------

  ACKEditHead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKEditHead& from);
  void MergeFrom(const ACKEditHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ACKEditHead)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKEditHead* default_instance_;
};
// -------------------------------------------------------------------

class REQEditUserName : public ::google::protobuf::Message {
 public:
  REQEditUserName();
  virtual ~REQEditUserName();

  REQEditUserName(const REQEditUserName& from);

  inline REQEditUserName& operator=(const REQEditUserName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQEditUserName& default_instance();

  void Swap(REQEditUserName* other);

  // implements Message ----------------------------------------------

  REQEditUserName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQEditUserName& from);
  void MergeFrom(const REQEditUserName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const void* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // optional int32 item_id = 3;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 3;
  inline ::google::protobuf::int32 item_id() const;
  inline void set_item_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQEditUserName)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_item_id();
  inline void clear_has_item_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 item_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQEditUserName* default_instance_;
};
// -------------------------------------------------------------------

class ACKEditUserName : public ::google::protobuf::Message {
 public:
  ACKEditUserName();
  virtual ~ACKEditUserName();

  ACKEditUserName(const ACKEditUserName& from);

  inline ACKEditUserName& operator=(const ACKEditUserName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKEditUserName& default_instance();

  void Swap(ACKEditUserName* other);

  // implements Message ----------------------------------------------

  ACKEditUserName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKEditUserName& from);
  void MergeFrom(const ACKEditUserName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required bytes username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const void* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:ACKEditUserName)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_username();
  inline void clear_has_username();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKEditUserName* default_instance_;
};
// -------------------------------------------------------------------

class REQGetRandingList : public ::google::protobuf::Message {
 public:
  REQGetRandingList();
  virtual ~REQGetRandingList();

  REQGetRandingList(const REQGetRandingList& from);

  inline REQGetRandingList& operator=(const REQGetRandingList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQGetRandingList& default_instance();

  void Swap(REQGetRandingList* other);

  // implements Message ----------------------------------------------

  REQGetRandingList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQGetRandingList& from);
  void MergeFrom(const REQGetRandingList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes req_msg = 1;
  inline bool has_req_msg() const;
  inline void clear_req_msg();
  static const int kReqMsgFieldNumber = 1;
  inline const ::std::string& req_msg() const;
  inline void set_req_msg(const ::std::string& value);
  inline void set_req_msg(const char* value);
  inline void set_req_msg(const void* value, size_t size);
  inline ::std::string* mutable_req_msg();
  inline ::std::string* release_req_msg();
  inline void set_allocated_req_msg(::std::string* req_msg);

  // optional int32 limit = 2;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 2;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);

  // optional int32 offset = 3;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQGetRandingList)
 private:
  inline void set_has_req_msg();
  inline void clear_has_req_msg();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_offset();
  inline void clear_has_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* req_msg_;
  ::google::protobuf::int32 limit_;
  ::google::protobuf::int32 offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQGetRandingList* default_instance_;
};
// -------------------------------------------------------------------

class ACKGetRandingList : public ::google::protobuf::Message {
 public:
  ACKGetRandingList();
  virtual ~ACKGetRandingList();

  ACKGetRandingList(const ACKGetRandingList& from);

  inline ACKGetRandingList& operator=(const ACKGetRandingList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKGetRandingList& default_instance();

  void Swap(ACKGetRandingList* other);

  // implements Message ----------------------------------------------

  ACKGetRandingList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKGetRandingList& from);
  void MergeFrom(const ACKGetRandingList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required bytes result_msg = 2;
  inline bool has_result_msg() const;
  inline void clear_result_msg();
  static const int kResultMsgFieldNumber = 2;
  inline const ::std::string& result_msg() const;
  inline void set_result_msg(const ::std::string& value);
  inline void set_result_msg(const char* value);
  inline void set_result_msg(const void* value, size_t size);
  inline ::std::string* mutable_result_msg();
  inline ::std::string* release_result_msg();
  inline void set_allocated_result_msg(::std::string* result_msg);

  // repeated .UserInfo userinfo_list = 3;
  inline int userinfo_list_size() const;
  inline void clear_userinfo_list();
  static const int kUserinfoListFieldNumber = 3;
  inline const ::UserInfo& userinfo_list(int index) const;
  inline ::UserInfo* mutable_userinfo_list(int index);
  inline ::UserInfo* add_userinfo_list();
  inline const ::google::protobuf::RepeatedPtrField< ::UserInfo >&
      userinfo_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::UserInfo >*
      mutable_userinfo_list();

  // optional int32 limit = 4;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 4;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);

  // optional int32 offset = 5;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 5;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ACKGetRandingList)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_result_msg();
  inline void clear_has_result_msg();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_offset();
  inline void clear_has_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_msg_;
  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 limit_;
  ::google::protobuf::RepeatedPtrField< ::UserInfo > userinfo_list_;
  ::google::protobuf::int32 offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKGetRandingList* default_instance_;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  Position* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 row = 1;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 1;
  inline ::google::protobuf::int32 row() const;
  inline void set_row(::google::protobuf::int32 value);

  // required int32 col = 2;
  inline bool has_col() const;
  inline void clear_col();
  static const int kColFieldNumber = 2;
  inline ::google::protobuf::int32 col() const;
  inline void set_col(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Position)
 private:
  inline void set_has_row();
  inline void clear_has_row();
  inline void set_has_col();
  inline void clear_has_col();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 row_;
  ::google::protobuf::int32 col_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class REQGameOver : public ::google::protobuf::Message {
 public:
  REQGameOver();
  virtual ~REQGameOver();

  REQGameOver(const REQGameOver& from);

  inline REQGameOver& operator=(const REQGameOver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQGameOver& default_instance();

  void Swap(REQGameOver* other);

  // implements Message ----------------------------------------------

  REQGameOver* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQGameOver& from);
  void MergeFrom(const REQGameOver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 winner_id = 1;
  inline bool has_winner_id() const;
  inline void clear_winner_id();
  static const int kWinnerIdFieldNumber = 1;
  inline ::google::protobuf::int32 winner_id() const;
  inline void set_winner_id(::google::protobuf::int32 value);

  // optional int32 loser_id = 2;
  inline bool has_loser_id() const;
  inline void clear_loser_id();
  static const int kLoserIdFieldNumber = 2;
  inline ::google::protobuf::int32 loser_id() const;
  inline void set_loser_id(::google::protobuf::int32 value);

  // optional int32 score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // required int32 black_id = 4;
  inline bool has_black_id() const;
  inline void clear_black_id();
  static const int kBlackIdFieldNumber = 4;
  inline ::google::protobuf::int32 black_id() const;
  inline void set_black_id(::google::protobuf::int32 value);

  // required int32 white_id = 5;
  inline bool has_white_id() const;
  inline void clear_white_id();
  static const int kWhiteIdFieldNumber = 5;
  inline ::google::protobuf::int32 white_id() const;
  inline void set_white_id(::google::protobuf::int32 value);

  // required bool is_no_winner = 6;
  inline bool has_is_no_winner() const;
  inline void clear_is_no_winner();
  static const int kIsNoWinnerFieldNumber = 6;
  inline bool is_no_winner() const;
  inline void set_is_no_winner(bool value);

  // required bool is_force_exit = 7;
  inline bool has_is_force_exit() const;
  inline void clear_is_force_exit();
  static const int kIsForceExitFieldNumber = 7;
  inline bool is_force_exit() const;
  inline void set_is_force_exit(bool value);

  // repeated .Position black_positions = 8;
  inline int black_positions_size() const;
  inline void clear_black_positions();
  static const int kBlackPositionsFieldNumber = 8;
  inline const ::Position& black_positions(int index) const;
  inline ::Position* mutable_black_positions(int index);
  inline ::Position* add_black_positions();
  inline const ::google::protobuf::RepeatedPtrField< ::Position >&
      black_positions() const;
  inline ::google::protobuf::RepeatedPtrField< ::Position >*
      mutable_black_positions();

  // repeated .Position white_positions = 9;
  inline int white_positions_size() const;
  inline void clear_white_positions();
  static const int kWhitePositionsFieldNumber = 9;
  inline const ::Position& white_positions(int index) const;
  inline ::Position* mutable_white_positions(int index);
  inline ::Position* add_white_positions();
  inline const ::google::protobuf::RepeatedPtrField< ::Position >&
      white_positions() const;
  inline ::google::protobuf::RepeatedPtrField< ::Position >*
      mutable_white_positions();

  // required int32 conis = 10;
  inline bool has_conis() const;
  inline void clear_conis();
  static const int kConisFieldNumber = 10;
  inline ::google::protobuf::int32 conis() const;
  inline void set_conis(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQGameOver)
 private:
  inline void set_has_winner_id();
  inline void clear_has_winner_id();
  inline void set_has_loser_id();
  inline void clear_has_loser_id();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_black_id();
  inline void clear_has_black_id();
  inline void set_has_white_id();
  inline void clear_has_white_id();
  inline void set_has_is_no_winner();
  inline void clear_has_is_no_winner();
  inline void set_has_is_force_exit();
  inline void clear_has_is_force_exit();
  inline void set_has_conis();
  inline void clear_has_conis();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 winner_id_;
  ::google::protobuf::int32 loser_id_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 black_id_;
  ::google::protobuf::int32 white_id_;
  bool is_no_winner_;
  bool is_force_exit_;
  ::google::protobuf::RepeatedPtrField< ::Position > black_positions_;
  ::google::protobuf::RepeatedPtrField< ::Position > white_positions_;
  ::google::protobuf::int32 conis_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQGameOver* default_instance_;
};
// -------------------------------------------------------------------

class REQGetGameHistory : public ::google::protobuf::Message {
 public:
  REQGetGameHistory();
  virtual ~REQGetGameHistory();

  REQGetGameHistory(const REQGetGameHistory& from);

  inline REQGetGameHistory& operator=(const REQGetGameHistory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQGetGameHistory& default_instance();

  void Swap(REQGetGameHistory* other);

  // implements Message ----------------------------------------------

  REQGetGameHistory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQGetGameHistory& from);
  void MergeFrom(const REQGetGameHistory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int32 player_id() const;
  inline void set_player_id(::google::protobuf::int32 value);

  // required int32 limit = 2;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 2;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);

  // required int32 offset = 3;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline ::google::protobuf::int32 offset() const;
  inline void set_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQGetGameHistory)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_offset();
  inline void clear_has_offset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 player_id_;
  ::google::protobuf::int32 limit_;
  ::google::protobuf::int32 offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQGetGameHistory* default_instance_;
};
// -------------------------------------------------------------------

class GameInfo : public ::google::protobuf::Message {
 public:
  GameInfo();
  virtual ~GameInfo();

  GameInfo(const GameInfo& from);

  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameInfo& default_instance();

  void Swap(GameInfo* other);

  // implements Message ----------------------------------------------

  GameInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameInfo& from);
  void MergeFrom(const GameInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .UserInfo enemy_userinfo = 1;
  inline bool has_enemy_userinfo() const;
  inline void clear_enemy_userinfo();
  static const int kEnemyUserinfoFieldNumber = 1;
  inline const ::UserInfo& enemy_userinfo() const;
  inline ::UserInfo* mutable_enemy_userinfo();
  inline ::UserInfo* release_enemy_userinfo();
  inline void set_allocated_enemy_userinfo(::UserInfo* enemy_userinfo);

  // required int32 game_id = 2;
  inline bool has_game_id() const;
  inline void clear_game_id();
  static const int kGameIdFieldNumber = 2;
  inline ::google::protobuf::int32 game_id() const;
  inline void set_game_id(::google::protobuf::int32 value);

  // required int32 winner_id = 3;
  inline bool has_winner_id() const;
  inline void clear_winner_id();
  static const int kWinnerIdFieldNumber = 3;
  inline ::google::protobuf::int32 winner_id() const;
  inline void set_winner_id(::google::protobuf::int32 value);

  // required int32 loser_id = 4;
  inline bool has_loser_id() const;
  inline void clear_loser_id();
  static const int kLoserIdFieldNumber = 4;
  inline ::google::protobuf::int32 loser_id() const;
  inline void set_loser_id(::google::protobuf::int32 value);

  // required int32 score = 5;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 5;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // required int32 black_id = 6;
  inline bool has_black_id() const;
  inline void clear_black_id();
  static const int kBlackIdFieldNumber = 6;
  inline ::google::protobuf::int32 black_id() const;
  inline void set_black_id(::google::protobuf::int32 value);

  // required int32 white_id = 7;
  inline bool has_white_id() const;
  inline void clear_white_id();
  static const int kWhiteIdFieldNumber = 7;
  inline ::google::protobuf::int32 white_id() const;
  inline void set_white_id(::google::protobuf::int32 value);

  // required bool is_no_winner = 8;
  inline bool has_is_no_winner() const;
  inline void clear_is_no_winner();
  static const int kIsNoWinnerFieldNumber = 8;
  inline bool is_no_winner() const;
  inline void set_is_no_winner(bool value);

  // required bool is_force_exit = 9;
  inline bool has_is_force_exit() const;
  inline void clear_is_force_exit();
  static const int kIsForceExitFieldNumber = 9;
  inline bool is_force_exit() const;
  inline void set_is_force_exit(bool value);

  // repeated .Position black_positions = 10;
  inline int black_positions_size() const;
  inline void clear_black_positions();
  static const int kBlackPositionsFieldNumber = 10;
  inline const ::Position& black_positions(int index) const;
  inline ::Position* mutable_black_positions(int index);
  inline ::Position* add_black_positions();
  inline const ::google::protobuf::RepeatedPtrField< ::Position >&
      black_positions() const;
  inline ::google::protobuf::RepeatedPtrField< ::Position >*
      mutable_black_positions();

  // repeated .Position white_positions = 11;
  inline int white_positions_size() const;
  inline void clear_white_positions();
  static const int kWhitePositionsFieldNumber = 11;
  inline const ::Position& white_positions(int index) const;
  inline ::Position* mutable_white_positions(int index);
  inline ::Position* add_white_positions();
  inline const ::google::protobuf::RepeatedPtrField< ::Position >&
      white_positions() const;
  inline ::google::protobuf::RepeatedPtrField< ::Position >*
      mutable_white_positions();

  // required bytes game_time = 12;
  inline bool has_game_time() const;
  inline void clear_game_time();
  static const int kGameTimeFieldNumber = 12;
  inline const ::std::string& game_time() const;
  inline void set_game_time(const ::std::string& value);
  inline void set_game_time(const char* value);
  inline void set_game_time(const void* value, size_t size);
  inline ::std::string* mutable_game_time();
  inline ::std::string* release_game_time();
  inline void set_allocated_game_time(::std::string* game_time);

  // @@protoc_insertion_point(class_scope:GameInfo)
 private:
  inline void set_has_enemy_userinfo();
  inline void clear_has_enemy_userinfo();
  inline void set_has_game_id();
  inline void clear_has_game_id();
  inline void set_has_winner_id();
  inline void clear_has_winner_id();
  inline void set_has_loser_id();
  inline void clear_has_loser_id();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_black_id();
  inline void clear_has_black_id();
  inline void set_has_white_id();
  inline void clear_has_white_id();
  inline void set_has_is_no_winner();
  inline void clear_has_is_no_winner();
  inline void set_has_is_force_exit();
  inline void clear_has_is_force_exit();
  inline void set_has_game_time();
  inline void clear_has_game_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserInfo* enemy_userinfo_;
  ::google::protobuf::int32 game_id_;
  ::google::protobuf::int32 winner_id_;
  ::google::protobuf::int32 loser_id_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 black_id_;
  ::google::protobuf::int32 white_id_;
  ::google::protobuf::RepeatedPtrField< ::Position > black_positions_;
  ::google::protobuf::RepeatedPtrField< ::Position > white_positions_;
  ::std::string* game_time_;
  bool is_no_winner_;
  bool is_force_exit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static GameInfo* default_instance_;
};
// -------------------------------------------------------------------

class ACKGetGameHistory : public ::google::protobuf::Message {
 public:
  ACKGetGameHistory();
  virtual ~ACKGetGameHistory();

  ACKGetGameHistory(const ACKGetGameHistory& from);

  inline ACKGetGameHistory& operator=(const ACKGetGameHistory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKGetGameHistory& default_instance();

  void Swap(ACKGetGameHistory* other);

  // implements Message ----------------------------------------------

  ACKGetGameHistory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKGetGameHistory& from);
  void MergeFrom(const ACKGetGameHistory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int32 player_id() const;
  inline void set_player_id(::google::protobuf::int32 value);

  // repeated .GameInfo game_info_list = 2;
  inline int game_info_list_size() const;
  inline void clear_game_info_list();
  static const int kGameInfoListFieldNumber = 2;
  inline const ::GameInfo& game_info_list(int index) const;
  inline ::GameInfo* mutable_game_info_list(int index);
  inline ::GameInfo* add_game_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::GameInfo >&
      game_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::GameInfo >*
      mutable_game_info_list();

  // @@protoc_insertion_point(class_scope:ACKGetGameHistory)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::GameInfo > game_info_list_;
  ::google::protobuf::int32 player_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKGetGameHistory* default_instance_;
};
// -------------------------------------------------------------------

class REQGetFriendInfo : public ::google::protobuf::Message {
 public:
  REQGetFriendInfo();
  virtual ~REQGetFriendInfo();

  REQGetFriendInfo(const REQGetFriendInfo& from);

  inline REQGetFriendInfo& operator=(const REQGetFriendInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQGetFriendInfo& default_instance();

  void Swap(REQGetFriendInfo* other);

  // implements Message ----------------------------------------------

  REQGetFriendInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQGetFriendInfo& from);
  void MergeFrom(const REQGetFriendInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes friend_name = 1;
  inline bool has_friend_name() const;
  inline void clear_friend_name();
  static const int kFriendNameFieldNumber = 1;
  inline const ::std::string& friend_name() const;
  inline void set_friend_name(const ::std::string& value);
  inline void set_friend_name(const char* value);
  inline void set_friend_name(const void* value, size_t size);
  inline ::std::string* mutable_friend_name();
  inline ::std::string* release_friend_name();
  inline void set_allocated_friend_name(::std::string* friend_name);

  // required int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQGetFriendInfo)
 private:
  inline void set_has_friend_name();
  inline void clear_has_friend_name();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* friend_name_;
  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQGetFriendInfo* default_instance_;
};
// -------------------------------------------------------------------

class ACKGetFriendInfo : public ::google::protobuf::Message {
 public:
  ACKGetFriendInfo();
  virtual ~ACKGetFriendInfo();

  ACKGetFriendInfo(const ACKGetFriendInfo& from);

  inline ACKGetFriendInfo& operator=(const ACKGetFriendInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKGetFriendInfo& default_instance();

  void Swap(ACKGetFriendInfo* other);

  // implements Message ----------------------------------------------

  ACKGetFriendInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKGetFriendInfo& from);
  void MergeFrom(const ACKGetFriendInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .UserInfo friendinfo = 1;
  inline bool has_friendinfo() const;
  inline void clear_friendinfo();
  static const int kFriendinfoFieldNumber = 1;
  inline const ::UserInfo& friendinfo() const;
  inline ::UserInfo* mutable_friendinfo();
  inline ::UserInfo* release_friendinfo();
  inline void set_allocated_friendinfo(::UserInfo* friendinfo);

  // required bool is_my_friend = 2;
  inline bool has_is_my_friend() const;
  inline void clear_is_my_friend();
  static const int kIsMyFriendFieldNumber = 2;
  inline bool is_my_friend() const;
  inline void set_is_my_friend(bool value);

  // required bool is_exist = 3;
  inline bool has_is_exist() const;
  inline void clear_is_exist();
  static const int kIsExistFieldNumber = 3;
  inline bool is_exist() const;
  inline void set_is_exist(bool value);

  // @@protoc_insertion_point(class_scope:ACKGetFriendInfo)
 private:
  inline void set_has_friendinfo();
  inline void clear_has_friendinfo();
  inline void set_has_is_my_friend();
  inline void clear_has_is_my_friend();
  inline void set_has_is_exist();
  inline void clear_has_is_exist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserInfo* friendinfo_;
  bool is_my_friend_;
  bool is_exist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKGetFriendInfo* default_instance_;
};
// -------------------------------------------------------------------

class REQAddFriend : public ::google::protobuf::Message {
 public:
  REQAddFriend();
  virtual ~REQAddFriend();

  REQAddFriend(const REQAddFriend& from);

  inline REQAddFriend& operator=(const REQAddFriend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQAddFriend& default_instance();

  void Swap(REQAddFriend* other);

  // implements Message ----------------------------------------------

  REQAddFriend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQAddFriend& from);
  void MergeFrom(const REQAddFriend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 friend_id = 1;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 1;
  inline ::google::protobuf::int32 friend_id() const;
  inline void set_friend_id(::google::protobuf::int32 value);

  // required int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQAddFriend)
 private:
  inline void set_has_friend_id();
  inline void clear_has_friend_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 friend_id_;
  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQAddFriend* default_instance_;
};
// -------------------------------------------------------------------

class ACKAddFriend : public ::google::protobuf::Message {
 public:
  ACKAddFriend();
  virtual ~ACKAddFriend();

  ACKAddFriend(const ACKAddFriend& from);

  inline ACKAddFriend& operator=(const ACKAddFriend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKAddFriend& default_instance();

  void Swap(ACKAddFriend* other);

  // implements Message ----------------------------------------------

  ACKAddFriend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKAddFriend& from);
  void MergeFrom(const ACKAddFriend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional bytes result_msg = 2;
  inline bool has_result_msg() const;
  inline void clear_result_msg();
  static const int kResultMsgFieldNumber = 2;
  inline const ::std::string& result_msg() const;
  inline void set_result_msg(const ::std::string& value);
  inline void set_result_msg(const char* value);
  inline void set_result_msg(const void* value, size_t size);
  inline ::std::string* mutable_result_msg();
  inline ::std::string* release_result_msg();
  inline void set_allocated_result_msg(::std::string* result_msg);

  // @@protoc_insertion_point(class_scope:ACKAddFriend)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_result_msg();
  inline void clear_has_result_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_msg_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKAddFriend* default_instance_;
};
// -------------------------------------------------------------------

class REQRequestFriend : public ::google::protobuf::Message {
 public:
  REQRequestFriend();
  virtual ~REQRequestFriend();

  REQRequestFriend(const REQRequestFriend& from);

  inline REQRequestFriend& operator=(const REQRequestFriend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQRequestFriend& default_instance();

  void Swap(REQRequestFriend* other);

  // implements Message ----------------------------------------------

  REQRequestFriend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQRequestFriend& from);
  void MergeFrom(const REQRequestFriend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 num = 1;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 1;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // required int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQRequestFriend)
 private:
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQRequestFriend* default_instance_;
};
// -------------------------------------------------------------------

class REQIsAgreeFriend : public ::google::protobuf::Message {
 public:
  REQIsAgreeFriend();
  virtual ~REQIsAgreeFriend();

  REQIsAgreeFriend(const REQIsAgreeFriend& from);

  inline REQIsAgreeFriend& operator=(const REQIsAgreeFriend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQIsAgreeFriend& default_instance();

  void Swap(REQIsAgreeFriend* other);

  // implements Message ----------------------------------------------

  REQIsAgreeFriend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQIsAgreeFriend& from);
  void MergeFrom(const REQIsAgreeFriend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 friend_id = 2;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 2;
  inline ::google::protobuf::int32 friend_id() const;
  inline void set_friend_id(::google::protobuf::int32 value);

  // required bool is_agree = 3;
  inline bool has_is_agree() const;
  inline void clear_is_agree();
  static const int kIsAgreeFieldNumber = 3;
  inline bool is_agree() const;
  inline void set_is_agree(bool value);

  // @@protoc_insertion_point(class_scope:REQIsAgreeFriend)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_friend_id();
  inline void clear_has_friend_id();
  inline void set_has_is_agree();
  inline void clear_has_is_agree();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 friend_id_;
  bool is_agree_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQIsAgreeFriend* default_instance_;
};
// -------------------------------------------------------------------

class ACKIsAgreeFriend : public ::google::protobuf::Message {
 public:
  ACKIsAgreeFriend();
  virtual ~ACKIsAgreeFriend();

  ACKIsAgreeFriend(const ACKIsAgreeFriend& from);

  inline ACKIsAgreeFriend& operator=(const ACKIsAgreeFriend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKIsAgreeFriend& default_instance();

  void Swap(ACKIsAgreeFriend* other);

  // implements Message ----------------------------------------------

  ACKIsAgreeFriend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKIsAgreeFriend& from);
  void MergeFrom(const ACKIsAgreeFriend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required bytes result_msg = 2;
  inline bool has_result_msg() const;
  inline void clear_result_msg();
  static const int kResultMsgFieldNumber = 2;
  inline const ::std::string& result_msg() const;
  inline void set_result_msg(const ::std::string& value);
  inline void set_result_msg(const char* value);
  inline void set_result_msg(const void* value, size_t size);
  inline ::std::string* mutable_result_msg();
  inline ::std::string* release_result_msg();
  inline void set_allocated_result_msg(::std::string* result_msg);

  // @@protoc_insertion_point(class_scope:ACKIsAgreeFriend)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_result_msg();
  inline void clear_has_result_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_msg_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKIsAgreeFriend* default_instance_;
};
// -------------------------------------------------------------------

class ACKUpdateFriend : public ::google::protobuf::Message {
 public:
  ACKUpdateFriend();
  virtual ~ACKUpdateFriend();

  ACKUpdateFriend(const ACKUpdateFriend& from);

  inline ACKUpdateFriend& operator=(const ACKUpdateFriend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKUpdateFriend& default_instance();

  void Swap(ACKUpdateFriend* other);

  // implements Message ----------------------------------------------

  ACKUpdateFriend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKUpdateFriend& from);
  void MergeFrom(const ACKUpdateFriend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required .UserInfo firendinfo = 2;
  inline bool has_firendinfo() const;
  inline void clear_firendinfo();
  static const int kFirendinfoFieldNumber = 2;
  inline const ::UserInfo& firendinfo() const;
  inline ::UserInfo* mutable_firendinfo();
  inline ::UserInfo* release_firendinfo();
  inline void set_allocated_firendinfo(::UserInfo* firendinfo);

  // @@protoc_insertion_point(class_scope:ACKUpdateFriend)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_firendinfo();
  inline void clear_has_firendinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserInfo* firendinfo_;
  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKUpdateFriend* default_instance_;
};
// -------------------------------------------------------------------

class REQFriendsList : public ::google::protobuf::Message {
 public:
  REQFriendsList();
  virtual ~REQFriendsList();

  REQFriendsList(const REQFriendsList& from);

  inline REQFriendsList& operator=(const REQFriendsList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQFriendsList& default_instance();

  void Swap(REQFriendsList* other);

  // implements Message ----------------------------------------------

  REQFriendsList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQFriendsList& from);
  void MergeFrom(const REQFriendsList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQFriendsList)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQFriendsList* default_instance_;
};
// -------------------------------------------------------------------

class ACKFriendsList : public ::google::protobuf::Message {
 public:
  ACKFriendsList();
  virtual ~ACKFriendsList();

  ACKFriendsList(const ACKFriendsList& from);

  inline ACKFriendsList& operator=(const ACKFriendsList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKFriendsList& default_instance();

  void Swap(ACKFriendsList* other);

  // implements Message ----------------------------------------------

  ACKFriendsList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKFriendsList& from);
  void MergeFrom(const ACKFriendsList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .UserInfo firendinfo = 1;
  inline int firendinfo_size() const;
  inline void clear_firendinfo();
  static const int kFirendinfoFieldNumber = 1;
  inline const ::UserInfo& firendinfo(int index) const;
  inline ::UserInfo* mutable_firendinfo(int index);
  inline ::UserInfo* add_firendinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::UserInfo >&
      firendinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::UserInfo >*
      mutable_firendinfo();

  // @@protoc_insertion_point(class_scope:ACKFriendsList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::UserInfo > firendinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKFriendsList* default_instance_;
};
// -------------------------------------------------------------------

class REQWaitFriendsList : public ::google::protobuf::Message {
 public:
  REQWaitFriendsList();
  virtual ~REQWaitFriendsList();

  REQWaitFriendsList(const REQWaitFriendsList& from);

  inline REQWaitFriendsList& operator=(const REQWaitFriendsList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQWaitFriendsList& default_instance();

  void Swap(REQWaitFriendsList* other);

  // implements Message ----------------------------------------------

  REQWaitFriendsList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQWaitFriendsList& from);
  void MergeFrom(const REQWaitFriendsList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQWaitFriendsList)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQWaitFriendsList* default_instance_;
};
// -------------------------------------------------------------------

class ACKWaitFriendsList : public ::google::protobuf::Message {
 public:
  ACKWaitFriendsList();
  virtual ~ACKWaitFriendsList();

  ACKWaitFriendsList(const ACKWaitFriendsList& from);

  inline ACKWaitFriendsList& operator=(const ACKWaitFriendsList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKWaitFriendsList& default_instance();

  void Swap(ACKWaitFriendsList* other);

  // implements Message ----------------------------------------------

  ACKWaitFriendsList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKWaitFriendsList& from);
  void MergeFrom(const ACKWaitFriendsList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .UserInfo firendinfo = 1;
  inline int firendinfo_size() const;
  inline void clear_firendinfo();
  static const int kFirendinfoFieldNumber = 1;
  inline const ::UserInfo& firendinfo(int index) const;
  inline ::UserInfo* mutable_firendinfo(int index);
  inline ::UserInfo* add_firendinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::UserInfo >&
      firendinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::UserInfo >*
      mutable_firendinfo();

  // repeated bytes times = 2;
  inline int times_size() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 2;
  inline const ::std::string& times(int index) const;
  inline ::std::string* mutable_times(int index);
  inline void set_times(int index, const ::std::string& value);
  inline void set_times(int index, const char* value);
  inline void set_times(int index, const void* value, size_t size);
  inline ::std::string* add_times();
  inline void add_times(const ::std::string& value);
  inline void add_times(const char* value);
  inline void add_times(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& times() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_times();

  // @@protoc_insertion_point(class_scope:ACKWaitFriendsList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::UserInfo > firendinfo_;
  ::google::protobuf::RepeatedPtrField< ::std::string> times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKWaitFriendsList* default_instance_;
};
// -------------------------------------------------------------------

class REQDeleteFriend : public ::google::protobuf::Message {
 public:
  REQDeleteFriend();
  virtual ~REQDeleteFriend();

  REQDeleteFriend(const REQDeleteFriend& from);

  inline REQDeleteFriend& operator=(const REQDeleteFriend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQDeleteFriend& default_instance();

  void Swap(REQDeleteFriend* other);

  // implements Message ----------------------------------------------

  REQDeleteFriend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQDeleteFriend& from);
  void MergeFrom(const REQDeleteFriend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 friend_id = 1;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 1;
  inline ::google::protobuf::int32 friend_id() const;
  inline void set_friend_id(::google::protobuf::int32 value);

  // required int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQDeleteFriend)
 private:
  inline void set_has_friend_id();
  inline void clear_has_friend_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 friend_id_;
  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQDeleteFriend* default_instance_;
};
// -------------------------------------------------------------------

class ACKDeleteFriend : public ::google::protobuf::Message {
 public:
  ACKDeleteFriend();
  virtual ~ACKDeleteFriend();

  ACKDeleteFriend(const ACKDeleteFriend& from);

  inline ACKDeleteFriend& operator=(const ACKDeleteFriend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKDeleteFriend& default_instance();

  void Swap(ACKDeleteFriend* other);

  // implements Message ----------------------------------------------

  ACKDeleteFriend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKDeleteFriend& from);
  void MergeFrom(const ACKDeleteFriend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional bytes result_msg = 2;
  inline bool has_result_msg() const;
  inline void clear_result_msg();
  static const int kResultMsgFieldNumber = 2;
  inline const ::std::string& result_msg() const;
  inline void set_result_msg(const ::std::string& value);
  inline void set_result_msg(const char* value);
  inline void set_result_msg(const void* value, size_t size);
  inline ::std::string* mutable_result_msg();
  inline ::std::string* release_result_msg();
  inline void set_allocated_result_msg(::std::string* result_msg);

  // @@protoc_insertion_point(class_scope:ACKDeleteFriend)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_result_msg();
  inline void clear_has_result_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_msg_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKDeleteFriend* default_instance_;
};
// -------------------------------------------------------------------

class REQBuy : public ::google::protobuf::Message {
 public:
  REQBuy();
  virtual ~REQBuy();

  REQBuy(const REQBuy& from);

  inline REQBuy& operator=(const REQBuy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQBuy& default_instance();

  void Swap(REQBuy* other);

  // implements Message ----------------------------------------------

  REQBuy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQBuy& from);
  void MergeFrom(const REQBuy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 item_id = 2;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::int32 item_id() const;
  inline void set_item_id(::google::protobuf::int32 value);

  // required int32 price = 3;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // required int32 num = 4;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 4;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQBuy)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 item_id_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQBuy* default_instance_;
};
// -------------------------------------------------------------------

class ACKBuy : public ::google::protobuf::Message {
 public:
  ACKBuy();
  virtual ~ACKBuy();

  ACKBuy(const ACKBuy& from);

  inline ACKBuy& operator=(const ACKBuy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKBuy& default_instance();

  void Swap(ACKBuy* other);

  // implements Message ----------------------------------------------

  ACKBuy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKBuy& from);
  void MergeFrom(const ACKBuy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required bytes result_msg = 2;
  inline bool has_result_msg() const;
  inline void clear_result_msg();
  static const int kResultMsgFieldNumber = 2;
  inline const ::std::string& result_msg() const;
  inline void set_result_msg(const ::std::string& value);
  inline void set_result_msg(const char* value);
  inline void set_result_msg(const void* value, size_t size);
  inline ::std::string* mutable_result_msg();
  inline ::std::string* release_result_msg();
  inline void set_allocated_result_msg(::std::string* result_msg);

  // optional int32 item_id = 3;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 3;
  inline ::google::protobuf::int32 item_id() const;
  inline void set_item_id(::google::protobuf::int32 value);

  // optional int32 price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional int32 num = 5;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 5;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ACKBuy)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_result_msg();
  inline void clear_has_result_msg();
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_msg_;
  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 item_id_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKBuy* default_instance_;
};
// ===================================================================


// ===================================================================

// REQHold

// -------------------------------------------------------------------

// ACKHold

// optional int32 result_id = 1;
inline bool ACKHold::has_result_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKHold::set_has_result_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKHold::clear_has_result_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKHold::clear_result_id() {
  result_id_ = 0;
  clear_has_result_id();
}
inline ::google::protobuf::int32 ACKHold::result_id() const {
  return result_id_;
}
inline void ACKHold::set_result_id(::google::protobuf::int32 value) {
  set_has_result_id();
  result_id_ = value;
}

// -------------------------------------------------------------------

// MsgPackage

// optional int64 msg_id = 1;
inline bool MsgPackage::has_msg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgPackage::set_has_msg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgPackage::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgPackage::clear_msg_id() {
  msg_id_ = GOOGLE_LONGLONG(0);
  clear_has_msg_id();
}
inline ::google::protobuf::int64 MsgPackage::msg_id() const {
  return msg_id_;
}
inline void MsgPackage::set_msg_id(::google::protobuf::int64 value) {
  set_has_msg_id();
  msg_id_ = value;
}

// optional int64 seq_id = 2;
inline bool MsgPackage::has_seq_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgPackage::set_has_seq_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgPackage::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgPackage::clear_seq_id() {
  seq_id_ = GOOGLE_LONGLONG(0);
  clear_has_seq_id();
}
inline ::google::protobuf::int64 MsgPackage::seq_id() const {
  return seq_id_;
}
inline void MsgPackage::set_seq_id(::google::protobuf::int64 value) {
  set_has_seq_id();
  seq_id_ = value;
}

// optional int64 user_id = 3;
inline bool MsgPackage::has_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgPackage::set_has_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgPackage::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgPackage::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 MsgPackage::user_id() const {
  return user_id_;
}
inline void MsgPackage::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
}

// optional bytes msg = 4;
inline bool MsgPackage::has_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgPackage::set_has_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgPackage::clear_has_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgPackage::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& MsgPackage::msg() const {
  return *msg_;
}
inline void MsgPackage::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void MsgPackage::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void MsgPackage::set_msg(const void* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgPackage::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* MsgPackage::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MsgPackage::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes src = 5;
inline bool MsgPackage::has_src() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgPackage::set_has_src() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgPackage::clear_has_src() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgPackage::clear_src() {
  if (src_ != &::google::protobuf::internal::kEmptyString) {
    src_->clear();
  }
  clear_has_src();
}
inline const ::std::string& MsgPackage::src() const {
  return *src_;
}
inline void MsgPackage::set_src(const ::std::string& value) {
  set_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    src_ = new ::std::string;
  }
  src_->assign(value);
}
inline void MsgPackage::set_src(const char* value) {
  set_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    src_ = new ::std::string;
  }
  src_->assign(value);
}
inline void MsgPackage::set_src(const void* value, size_t size) {
  set_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    src_ = new ::std::string;
  }
  src_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgPackage::mutable_src() {
  set_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    src_ = new ::std::string;
  }
  return src_;
}
inline ::std::string* MsgPackage::release_src() {
  clear_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src_;
    src_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MsgPackage::set_allocated_src(::std::string* src) {
  if (src_ != &::google::protobuf::internal::kEmptyString) {
    delete src_;
  }
  if (src) {
    set_has_src();
    src_ = src;
  } else {
    clear_has_src();
    src_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 clientid = 6;
inline bool MsgPackage::has_clientid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgPackage::set_has_clientid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgPackage::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgPackage::clear_clientid() {
  clientid_ = GOOGLE_LONGLONG(0);
  clear_has_clientid();
}
inline ::google::protobuf::int64 MsgPackage::clientid() const {
  return clientid_;
}
inline void MsgPackage::set_clientid(::google::protobuf::int64 value) {
  set_has_clientid();
  clientid_ = value;
}

// -------------------------------------------------------------------

// REQRegister

// optional bytes account = 1;
inline bool REQRegister::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQRegister::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQRegister::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQRegister::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& REQRegister::account() const {
  return *account_;
}
inline void REQRegister::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void REQRegister::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void REQRegister::set_account(const void* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQRegister::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* REQRegister::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void REQRegister::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes passwd = 2;
inline bool REQRegister::has_passwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQRegister::set_has_passwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQRegister::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQRegister::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& REQRegister::passwd() const {
  return *passwd_;
}
inline void REQRegister::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void REQRegister::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void REQRegister::set_passwd(const void* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQRegister::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* REQRegister::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void REQRegister::set_allocated_passwd(::std::string* passwd) {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    delete passwd_;
  }
  if (passwd) {
    set_has_passwd();
    passwd_ = passwd;
  } else {
    clear_has_passwd();
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ACKRegister

// optional int32 code = 1;
inline bool ACKRegister::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKRegister::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKRegister::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKRegister::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKRegister::code() const {
  return code_;
}
inline void ACKRegister::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional bytes result = 2;
inline bool ACKRegister::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKRegister::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKRegister::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKRegister::clear_result() {
  if (result_ != &::google::protobuf::internal::kEmptyString) {
    result_->clear();
  }
  clear_has_result();
}
inline const ::std::string& ACKRegister::result() const {
  return *result_;
}
inline void ACKRegister::set_result(const ::std::string& value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void ACKRegister::set_result(const char* value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void ACKRegister::set_result(const void* value, size_t size) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKRegister::mutable_result() {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  return result_;
}
inline ::std::string* ACKRegister::release_result() {
  clear_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_;
    result_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKRegister::set_allocated_result(::std::string* result) {
  if (result_ != &::google::protobuf::internal::kEmptyString) {
    delete result_;
  }
  if (result) {
    set_has_result();
    result_ = result;
  } else {
    clear_has_result();
    result_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// REQLogin

// optional bytes account = 1;
inline bool REQLogin::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQLogin::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQLogin::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQLogin::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& REQLogin::account() const {
  return *account_;
}
inline void REQLogin::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void REQLogin::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void REQLogin::set_account(const void* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQLogin::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* REQLogin::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void REQLogin::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes passwd = 2;
inline bool REQLogin::has_passwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQLogin::set_has_passwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQLogin::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQLogin::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& REQLogin::passwd() const {
  return *passwd_;
}
inline void REQLogin::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void REQLogin::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void REQLogin::set_passwd(const void* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQLogin::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* REQLogin::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void REQLogin::set_allocated_passwd(::std::string* passwd) {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    delete passwd_;
  }
  if (passwd) {
    set_has_passwd();
    passwd_ = passwd;
  } else {
    clear_has_passwd();
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ACKLogin

// optional int32 code = 1;
inline bool ACKLogin::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKLogin::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKLogin::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKLogin::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKLogin::code() const {
  return code_;
}
inline void ACKLogin::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional .UserInfo userinfo = 2;
inline bool ACKLogin::has_userinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKLogin::set_has_userinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKLogin::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKLogin::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::UserInfo& ACKLogin::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::UserInfo* ACKLogin::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::UserInfo;
  return userinfo_;
}
inline ::UserInfo* ACKLogin::release_userinfo() {
  clear_has_userinfo();
  ::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void ACKLogin::set_allocated_userinfo(::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
}

// -------------------------------------------------------------------

// UserInfo_Prop

// optional int32 id = 1;
inline bool UserInfo_Prop::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo_Prop::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo_Prop::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo_Prop::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UserInfo_Prop::id() const {
  return id_;
}
inline void UserInfo_Prop::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 quantity = 2;
inline bool UserInfo_Prop::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo_Prop::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo_Prop::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo_Prop::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline ::google::protobuf::int32 UserInfo_Prop::quantity() const {
  return quantity_;
}
inline void UserInfo_Prop::set_quantity(::google::protobuf::int32 value) {
  set_has_quantity();
  quantity_ = value;
}

// -------------------------------------------------------------------

// UserInfo

// optional int32 id = 1;
inline bool UserInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UserInfo::id() const {
  return id_;
}
inline void UserInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional bytes username = 2;
inline bool UserInfo::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& UserInfo::username() const {
  return *username_;
}
inline void UserInfo::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void UserInfo::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void UserInfo::set_username(const void* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* UserInfo::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 wintimes = 3;
inline bool UserInfo::has_wintimes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_wintimes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_wintimes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_wintimes() {
  wintimes_ = 0;
  clear_has_wintimes();
}
inline ::google::protobuf::int32 UserInfo::wintimes() const {
  return wintimes_;
}
inline void UserInfo::set_wintimes(::google::protobuf::int32 value) {
  set_has_wintimes();
  wintimes_ = value;
}

// optional int32 losetimes = 4;
inline bool UserInfo::has_losetimes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_losetimes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_losetimes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_losetimes() {
  losetimes_ = 0;
  clear_has_losetimes();
}
inline ::google::protobuf::int32 UserInfo::losetimes() const {
  return losetimes_;
}
inline void UserInfo::set_losetimes(::google::protobuf::int32 value) {
  set_has_losetimes();
  losetimes_ = value;
}

// optional int32 score = 5;
inline bool UserInfo::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 UserInfo::score() const {
  return score_;
}
inline void UserInfo::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// optional int32 level = 6;
inline bool UserInfo::has_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 UserInfo::level() const {
  return level_;
}
inline void UserInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 xp = 7;
inline bool UserInfo::has_xp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfo::set_has_xp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfo::clear_has_xp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfo::clear_xp() {
  xp_ = 0;
  clear_has_xp();
}
inline ::google::protobuf::int32 UserInfo::xp() const {
  return xp_;
}
inline void UserInfo::set_xp(::google::protobuf::int32 value) {
  set_has_xp();
  xp_ = value;
}

// optional int32 head_id = 8;
inline bool UserInfo::has_head_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfo::set_has_head_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfo::clear_has_head_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfo::clear_head_id() {
  head_id_ = 0;
  clear_has_head_id();
}
inline ::google::protobuf::int32 UserInfo::head_id() const {
  return head_id_;
}
inline void UserInfo::set_head_id(::google::protobuf::int32 value) {
  set_has_head_id();
  head_id_ = value;
}

// optional bool is_online = 9;
inline bool UserInfo::has_is_online() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfo::set_has_is_online() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfo::clear_has_is_online() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfo::clear_is_online() {
  is_online_ = false;
  clear_has_is_online();
}
inline bool UserInfo::is_online() const {
  return is_online_;
}
inline void UserInfo::set_is_online(bool value) {
  set_has_is_online();
  is_online_ = value;
}

// optional int32 coins = 10;
inline bool UserInfo::has_coins() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserInfo::set_has_coins() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserInfo::clear_has_coins() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserInfo::clear_coins() {
  coins_ = 0;
  clear_has_coins();
}
inline ::google::protobuf::int32 UserInfo::coins() const {
  return coins_;
}
inline void UserInfo::set_coins(::google::protobuf::int32 value) {
  set_has_coins();
  coins_ = value;
}

// repeated .UserInfo.Prop props = 11;
inline int UserInfo::props_size() const {
  return props_.size();
}
inline void UserInfo::clear_props() {
  props_.Clear();
}
inline const ::UserInfo_Prop& UserInfo::props(int index) const {
  return props_.Get(index);
}
inline ::UserInfo_Prop* UserInfo::mutable_props(int index) {
  return props_.Mutable(index);
}
inline ::UserInfo_Prop* UserInfo::add_props() {
  return props_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UserInfo_Prop >&
UserInfo::props() const {
  return props_;
}
inline ::google::protobuf::RepeatedPtrField< ::UserInfo_Prop >*
UserInfo::mutable_props() {
  return &props_;
}

// optional bytes account = 12;
inline bool UserInfo::has_account() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserInfo::set_has_account() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserInfo::clear_has_account() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserInfo::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& UserInfo::account() const {
  return *account_;
}
inline void UserInfo::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void UserInfo::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void UserInfo::set_account(const void* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* UserInfo::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// REQGetUserInfo

// required int32 user_id = 1;
inline bool REQGetUserInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQGetUserInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQGetUserInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQGetUserInfo::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQGetUserInfo::user_id() const {
  return user_id_;
}
inline void REQGetUserInfo::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// ACKGetUserInfo

// required int32 result_id = 1;
inline bool ACKGetUserInfo::has_result_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKGetUserInfo::set_has_result_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKGetUserInfo::clear_has_result_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKGetUserInfo::clear_result_id() {
  result_id_ = 0;
  clear_has_result_id();
}
inline ::google::protobuf::int32 ACKGetUserInfo::result_id() const {
  return result_id_;
}
inline void ACKGetUserInfo::set_result_id(::google::protobuf::int32 value) {
  set_has_result_id();
  result_id_ = value;
}

// required .UserInfo userinfo = 2;
inline bool ACKGetUserInfo::has_userinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKGetUserInfo::set_has_userinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKGetUserInfo::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKGetUserInfo::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::UserInfo& ACKGetUserInfo::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::UserInfo* ACKGetUserInfo::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::UserInfo;
  return userinfo_;
}
inline ::UserInfo* ACKGetUserInfo::release_userinfo() {
  clear_has_userinfo();
  ::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void ACKGetUserInfo::set_allocated_userinfo(::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
}

// -------------------------------------------------------------------

// REQEditHead

// optional int32 head_num = 1;
inline bool REQEditHead::has_head_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQEditHead::set_has_head_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQEditHead::clear_has_head_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQEditHead::clear_head_num() {
  head_num_ = 0;
  clear_has_head_num();
}
inline ::google::protobuf::int32 REQEditHead::head_num() const {
  return head_num_;
}
inline void REQEditHead::set_head_num(::google::protobuf::int32 value) {
  set_has_head_num();
  head_num_ = value;
}

// optional int32 user_id = 2;
inline bool REQEditHead::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQEditHead::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQEditHead::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQEditHead::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQEditHead::user_id() const {
  return user_id_;
}
inline void REQEditHead::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// ACKEditHead

// optional int32 code = 1;
inline bool ACKEditHead::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKEditHead::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKEditHead::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKEditHead::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKEditHead::code() const {
  return code_;
}
inline void ACKEditHead::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// REQEditUserName

// required bytes username = 1;
inline bool REQEditUserName::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQEditUserName::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQEditUserName::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQEditUserName::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& REQEditUserName::username() const {
  return *username_;
}
inline void REQEditUserName::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void REQEditUserName::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void REQEditUserName::set_username(const void* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQEditUserName::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* REQEditUserName::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void REQEditUserName::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 user_id = 2;
inline bool REQEditUserName::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQEditUserName::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQEditUserName::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQEditUserName::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQEditUserName::user_id() const {
  return user_id_;
}
inline void REQEditUserName::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// optional int32 item_id = 3;
inline bool REQEditUserName::has_item_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQEditUserName::set_has_item_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQEditUserName::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQEditUserName::clear_item_id() {
  item_id_ = 0;
  clear_has_item_id();
}
inline ::google::protobuf::int32 REQEditUserName::item_id() const {
  return item_id_;
}
inline void REQEditUserName::set_item_id(::google::protobuf::int32 value) {
  set_has_item_id();
  item_id_ = value;
}

// -------------------------------------------------------------------

// ACKEditUserName

// required int32 code = 1;
inline bool ACKEditUserName::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKEditUserName::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKEditUserName::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKEditUserName::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKEditUserName::code() const {
  return code_;
}
inline void ACKEditUserName::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required bytes username = 2;
inline bool ACKEditUserName::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKEditUserName::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKEditUserName::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKEditUserName::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ACKEditUserName::username() const {
  return *username_;
}
inline void ACKEditUserName::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ACKEditUserName::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ACKEditUserName::set_username(const void* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKEditUserName::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ACKEditUserName::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKEditUserName::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// REQGetRandingList

// required bytes req_msg = 1;
inline bool REQGetRandingList::has_req_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQGetRandingList::set_has_req_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQGetRandingList::clear_has_req_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQGetRandingList::clear_req_msg() {
  if (req_msg_ != &::google::protobuf::internal::kEmptyString) {
    req_msg_->clear();
  }
  clear_has_req_msg();
}
inline const ::std::string& REQGetRandingList::req_msg() const {
  return *req_msg_;
}
inline void REQGetRandingList::set_req_msg(const ::std::string& value) {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  req_msg_->assign(value);
}
inline void REQGetRandingList::set_req_msg(const char* value) {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  req_msg_->assign(value);
}
inline void REQGetRandingList::set_req_msg(const void* value, size_t size) {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  req_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQGetRandingList::mutable_req_msg() {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  return req_msg_;
}
inline ::std::string* REQGetRandingList::release_req_msg() {
  clear_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = req_msg_;
    req_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void REQGetRandingList::set_allocated_req_msg(::std::string* req_msg) {
  if (req_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete req_msg_;
  }
  if (req_msg) {
    set_has_req_msg();
    req_msg_ = req_msg;
  } else {
    clear_has_req_msg();
    req_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 limit = 2;
inline bool REQGetRandingList::has_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQGetRandingList::set_has_limit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQGetRandingList::clear_has_limit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQGetRandingList::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 REQGetRandingList::limit() const {
  return limit_;
}
inline void REQGetRandingList::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// optional int32 offset = 3;
inline bool REQGetRandingList::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQGetRandingList::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQGetRandingList::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQGetRandingList::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 REQGetRandingList::offset() const {
  return offset_;
}
inline void REQGetRandingList::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// -------------------------------------------------------------------

// ACKGetRandingList

// required int32 code = 1;
inline bool ACKGetRandingList::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKGetRandingList::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKGetRandingList::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKGetRandingList::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKGetRandingList::code() const {
  return code_;
}
inline void ACKGetRandingList::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required bytes result_msg = 2;
inline bool ACKGetRandingList::has_result_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKGetRandingList::set_has_result_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKGetRandingList::clear_has_result_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKGetRandingList::clear_result_msg() {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    result_msg_->clear();
  }
  clear_has_result_msg();
}
inline const ::std::string& ACKGetRandingList::result_msg() const {
  return *result_msg_;
}
inline void ACKGetRandingList::set_result_msg(const ::std::string& value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKGetRandingList::set_result_msg(const char* value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKGetRandingList::set_result_msg(const void* value, size_t size) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKGetRandingList::mutable_result_msg() {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  return result_msg_;
}
inline ::std::string* ACKGetRandingList::release_result_msg() {
  clear_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_msg_;
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKGetRandingList::set_allocated_result_msg(::std::string* result_msg) {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete result_msg_;
  }
  if (result_msg) {
    set_has_result_msg();
    result_msg_ = result_msg;
  } else {
    clear_has_result_msg();
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .UserInfo userinfo_list = 3;
inline int ACKGetRandingList::userinfo_list_size() const {
  return userinfo_list_.size();
}
inline void ACKGetRandingList::clear_userinfo_list() {
  userinfo_list_.Clear();
}
inline const ::UserInfo& ACKGetRandingList::userinfo_list(int index) const {
  return userinfo_list_.Get(index);
}
inline ::UserInfo* ACKGetRandingList::mutable_userinfo_list(int index) {
  return userinfo_list_.Mutable(index);
}
inline ::UserInfo* ACKGetRandingList::add_userinfo_list() {
  return userinfo_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UserInfo >&
ACKGetRandingList::userinfo_list() const {
  return userinfo_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::UserInfo >*
ACKGetRandingList::mutable_userinfo_list() {
  return &userinfo_list_;
}

// optional int32 limit = 4;
inline bool ACKGetRandingList::has_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACKGetRandingList::set_has_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACKGetRandingList::clear_has_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACKGetRandingList::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 ACKGetRandingList::limit() const {
  return limit_;
}
inline void ACKGetRandingList::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// optional int32 offset = 5;
inline bool ACKGetRandingList::has_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ACKGetRandingList::set_has_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ACKGetRandingList::clear_has_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ACKGetRandingList::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 ACKGetRandingList::offset() const {
  return offset_;
}
inline void ACKGetRandingList::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// -------------------------------------------------------------------

// Position

// required int32 row = 1;
inline bool Position::has_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_row() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_row() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_row() {
  row_ = 0;
  clear_has_row();
}
inline ::google::protobuf::int32 Position::row() const {
  return row_;
}
inline void Position::set_row(::google::protobuf::int32 value) {
  set_has_row();
  row_ = value;
}

// required int32 col = 2;
inline bool Position::has_col() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_col() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_col() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_col() {
  col_ = 0;
  clear_has_col();
}
inline ::google::protobuf::int32 Position::col() const {
  return col_;
}
inline void Position::set_col(::google::protobuf::int32 value) {
  set_has_col();
  col_ = value;
}

// -------------------------------------------------------------------

// REQGameOver

// optional int32 winner_id = 1;
inline bool REQGameOver::has_winner_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQGameOver::set_has_winner_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQGameOver::clear_has_winner_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQGameOver::clear_winner_id() {
  winner_id_ = 0;
  clear_has_winner_id();
}
inline ::google::protobuf::int32 REQGameOver::winner_id() const {
  return winner_id_;
}
inline void REQGameOver::set_winner_id(::google::protobuf::int32 value) {
  set_has_winner_id();
  winner_id_ = value;
}

// optional int32 loser_id = 2;
inline bool REQGameOver::has_loser_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQGameOver::set_has_loser_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQGameOver::clear_has_loser_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQGameOver::clear_loser_id() {
  loser_id_ = 0;
  clear_has_loser_id();
}
inline ::google::protobuf::int32 REQGameOver::loser_id() const {
  return loser_id_;
}
inline void REQGameOver::set_loser_id(::google::protobuf::int32 value) {
  set_has_loser_id();
  loser_id_ = value;
}

// optional int32 score = 3;
inline bool REQGameOver::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQGameOver::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQGameOver::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQGameOver::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 REQGameOver::score() const {
  return score_;
}
inline void REQGameOver::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// required int32 black_id = 4;
inline bool REQGameOver::has_black_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void REQGameOver::set_has_black_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void REQGameOver::clear_has_black_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void REQGameOver::clear_black_id() {
  black_id_ = 0;
  clear_has_black_id();
}
inline ::google::protobuf::int32 REQGameOver::black_id() const {
  return black_id_;
}
inline void REQGameOver::set_black_id(::google::protobuf::int32 value) {
  set_has_black_id();
  black_id_ = value;
}

// required int32 white_id = 5;
inline bool REQGameOver::has_white_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void REQGameOver::set_has_white_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void REQGameOver::clear_has_white_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void REQGameOver::clear_white_id() {
  white_id_ = 0;
  clear_has_white_id();
}
inline ::google::protobuf::int32 REQGameOver::white_id() const {
  return white_id_;
}
inline void REQGameOver::set_white_id(::google::protobuf::int32 value) {
  set_has_white_id();
  white_id_ = value;
}

// required bool is_no_winner = 6;
inline bool REQGameOver::has_is_no_winner() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void REQGameOver::set_has_is_no_winner() {
  _has_bits_[0] |= 0x00000020u;
}
inline void REQGameOver::clear_has_is_no_winner() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void REQGameOver::clear_is_no_winner() {
  is_no_winner_ = false;
  clear_has_is_no_winner();
}
inline bool REQGameOver::is_no_winner() const {
  return is_no_winner_;
}
inline void REQGameOver::set_is_no_winner(bool value) {
  set_has_is_no_winner();
  is_no_winner_ = value;
}

// required bool is_force_exit = 7;
inline bool REQGameOver::has_is_force_exit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void REQGameOver::set_has_is_force_exit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void REQGameOver::clear_has_is_force_exit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void REQGameOver::clear_is_force_exit() {
  is_force_exit_ = false;
  clear_has_is_force_exit();
}
inline bool REQGameOver::is_force_exit() const {
  return is_force_exit_;
}
inline void REQGameOver::set_is_force_exit(bool value) {
  set_has_is_force_exit();
  is_force_exit_ = value;
}

// repeated .Position black_positions = 8;
inline int REQGameOver::black_positions_size() const {
  return black_positions_.size();
}
inline void REQGameOver::clear_black_positions() {
  black_positions_.Clear();
}
inline const ::Position& REQGameOver::black_positions(int index) const {
  return black_positions_.Get(index);
}
inline ::Position* REQGameOver::mutable_black_positions(int index) {
  return black_positions_.Mutable(index);
}
inline ::Position* REQGameOver::add_black_positions() {
  return black_positions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Position >&
REQGameOver::black_positions() const {
  return black_positions_;
}
inline ::google::protobuf::RepeatedPtrField< ::Position >*
REQGameOver::mutable_black_positions() {
  return &black_positions_;
}

// repeated .Position white_positions = 9;
inline int REQGameOver::white_positions_size() const {
  return white_positions_.size();
}
inline void REQGameOver::clear_white_positions() {
  white_positions_.Clear();
}
inline const ::Position& REQGameOver::white_positions(int index) const {
  return white_positions_.Get(index);
}
inline ::Position* REQGameOver::mutable_white_positions(int index) {
  return white_positions_.Mutable(index);
}
inline ::Position* REQGameOver::add_white_positions() {
  return white_positions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Position >&
REQGameOver::white_positions() const {
  return white_positions_;
}
inline ::google::protobuf::RepeatedPtrField< ::Position >*
REQGameOver::mutable_white_positions() {
  return &white_positions_;
}

// required int32 conis = 10;
inline bool REQGameOver::has_conis() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void REQGameOver::set_has_conis() {
  _has_bits_[0] |= 0x00000200u;
}
inline void REQGameOver::clear_has_conis() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void REQGameOver::clear_conis() {
  conis_ = 0;
  clear_has_conis();
}
inline ::google::protobuf::int32 REQGameOver::conis() const {
  return conis_;
}
inline void REQGameOver::set_conis(::google::protobuf::int32 value) {
  set_has_conis();
  conis_ = value;
}

// -------------------------------------------------------------------

// REQGetGameHistory

// required int32 player_id = 1;
inline bool REQGetGameHistory::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQGetGameHistory::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQGetGameHistory::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQGetGameHistory::clear_player_id() {
  player_id_ = 0;
  clear_has_player_id();
}
inline ::google::protobuf::int32 REQGetGameHistory::player_id() const {
  return player_id_;
}
inline void REQGetGameHistory::set_player_id(::google::protobuf::int32 value) {
  set_has_player_id();
  player_id_ = value;
}

// required int32 limit = 2;
inline bool REQGetGameHistory::has_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQGetGameHistory::set_has_limit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQGetGameHistory::clear_has_limit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQGetGameHistory::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 REQGetGameHistory::limit() const {
  return limit_;
}
inline void REQGetGameHistory::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// required int32 offset = 3;
inline bool REQGetGameHistory::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQGetGameHistory::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQGetGameHistory::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQGetGameHistory::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 REQGetGameHistory::offset() const {
  return offset_;
}
inline void REQGetGameHistory::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
}

// -------------------------------------------------------------------

// GameInfo

// required .UserInfo enemy_userinfo = 1;
inline bool GameInfo::has_enemy_userinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameInfo::set_has_enemy_userinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameInfo::clear_has_enemy_userinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameInfo::clear_enemy_userinfo() {
  if (enemy_userinfo_ != NULL) enemy_userinfo_->::UserInfo::Clear();
  clear_has_enemy_userinfo();
}
inline const ::UserInfo& GameInfo::enemy_userinfo() const {
  return enemy_userinfo_ != NULL ? *enemy_userinfo_ : *default_instance_->enemy_userinfo_;
}
inline ::UserInfo* GameInfo::mutable_enemy_userinfo() {
  set_has_enemy_userinfo();
  if (enemy_userinfo_ == NULL) enemy_userinfo_ = new ::UserInfo;
  return enemy_userinfo_;
}
inline ::UserInfo* GameInfo::release_enemy_userinfo() {
  clear_has_enemy_userinfo();
  ::UserInfo* temp = enemy_userinfo_;
  enemy_userinfo_ = NULL;
  return temp;
}
inline void GameInfo::set_allocated_enemy_userinfo(::UserInfo* enemy_userinfo) {
  delete enemy_userinfo_;
  enemy_userinfo_ = enemy_userinfo;
  if (enemy_userinfo) {
    set_has_enemy_userinfo();
  } else {
    clear_has_enemy_userinfo();
  }
}

// required int32 game_id = 2;
inline bool GameInfo::has_game_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameInfo::set_has_game_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameInfo::clear_has_game_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameInfo::clear_game_id() {
  game_id_ = 0;
  clear_has_game_id();
}
inline ::google::protobuf::int32 GameInfo::game_id() const {
  return game_id_;
}
inline void GameInfo::set_game_id(::google::protobuf::int32 value) {
  set_has_game_id();
  game_id_ = value;
}

// required int32 winner_id = 3;
inline bool GameInfo::has_winner_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameInfo::set_has_winner_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameInfo::clear_has_winner_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameInfo::clear_winner_id() {
  winner_id_ = 0;
  clear_has_winner_id();
}
inline ::google::protobuf::int32 GameInfo::winner_id() const {
  return winner_id_;
}
inline void GameInfo::set_winner_id(::google::protobuf::int32 value) {
  set_has_winner_id();
  winner_id_ = value;
}

// required int32 loser_id = 4;
inline bool GameInfo::has_loser_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameInfo::set_has_loser_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameInfo::clear_has_loser_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameInfo::clear_loser_id() {
  loser_id_ = 0;
  clear_has_loser_id();
}
inline ::google::protobuf::int32 GameInfo::loser_id() const {
  return loser_id_;
}
inline void GameInfo::set_loser_id(::google::protobuf::int32 value) {
  set_has_loser_id();
  loser_id_ = value;
}

// required int32 score = 5;
inline bool GameInfo::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameInfo::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameInfo::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 GameInfo::score() const {
  return score_;
}
inline void GameInfo::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// required int32 black_id = 6;
inline bool GameInfo::has_black_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameInfo::set_has_black_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameInfo::clear_has_black_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameInfo::clear_black_id() {
  black_id_ = 0;
  clear_has_black_id();
}
inline ::google::protobuf::int32 GameInfo::black_id() const {
  return black_id_;
}
inline void GameInfo::set_black_id(::google::protobuf::int32 value) {
  set_has_black_id();
  black_id_ = value;
}

// required int32 white_id = 7;
inline bool GameInfo::has_white_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameInfo::set_has_white_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameInfo::clear_has_white_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameInfo::clear_white_id() {
  white_id_ = 0;
  clear_has_white_id();
}
inline ::google::protobuf::int32 GameInfo::white_id() const {
  return white_id_;
}
inline void GameInfo::set_white_id(::google::protobuf::int32 value) {
  set_has_white_id();
  white_id_ = value;
}

// required bool is_no_winner = 8;
inline bool GameInfo::has_is_no_winner() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameInfo::set_has_is_no_winner() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameInfo::clear_has_is_no_winner() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameInfo::clear_is_no_winner() {
  is_no_winner_ = false;
  clear_has_is_no_winner();
}
inline bool GameInfo::is_no_winner() const {
  return is_no_winner_;
}
inline void GameInfo::set_is_no_winner(bool value) {
  set_has_is_no_winner();
  is_no_winner_ = value;
}

// required bool is_force_exit = 9;
inline bool GameInfo::has_is_force_exit() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GameInfo::set_has_is_force_exit() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GameInfo::clear_has_is_force_exit() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GameInfo::clear_is_force_exit() {
  is_force_exit_ = false;
  clear_has_is_force_exit();
}
inline bool GameInfo::is_force_exit() const {
  return is_force_exit_;
}
inline void GameInfo::set_is_force_exit(bool value) {
  set_has_is_force_exit();
  is_force_exit_ = value;
}

// repeated .Position black_positions = 10;
inline int GameInfo::black_positions_size() const {
  return black_positions_.size();
}
inline void GameInfo::clear_black_positions() {
  black_positions_.Clear();
}
inline const ::Position& GameInfo::black_positions(int index) const {
  return black_positions_.Get(index);
}
inline ::Position* GameInfo::mutable_black_positions(int index) {
  return black_positions_.Mutable(index);
}
inline ::Position* GameInfo::add_black_positions() {
  return black_positions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Position >&
GameInfo::black_positions() const {
  return black_positions_;
}
inline ::google::protobuf::RepeatedPtrField< ::Position >*
GameInfo::mutable_black_positions() {
  return &black_positions_;
}

// repeated .Position white_positions = 11;
inline int GameInfo::white_positions_size() const {
  return white_positions_.size();
}
inline void GameInfo::clear_white_positions() {
  white_positions_.Clear();
}
inline const ::Position& GameInfo::white_positions(int index) const {
  return white_positions_.Get(index);
}
inline ::Position* GameInfo::mutable_white_positions(int index) {
  return white_positions_.Mutable(index);
}
inline ::Position* GameInfo::add_white_positions() {
  return white_positions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Position >&
GameInfo::white_positions() const {
  return white_positions_;
}
inline ::google::protobuf::RepeatedPtrField< ::Position >*
GameInfo::mutable_white_positions() {
  return &white_positions_;
}

// required bytes game_time = 12;
inline bool GameInfo::has_game_time() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GameInfo::set_has_game_time() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GameInfo::clear_has_game_time() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GameInfo::clear_game_time() {
  if (game_time_ != &::google::protobuf::internal::kEmptyString) {
    game_time_->clear();
  }
  clear_has_game_time();
}
inline const ::std::string& GameInfo::game_time() const {
  return *game_time_;
}
inline void GameInfo::set_game_time(const ::std::string& value) {
  set_has_game_time();
  if (game_time_ == &::google::protobuf::internal::kEmptyString) {
    game_time_ = new ::std::string;
  }
  game_time_->assign(value);
}
inline void GameInfo::set_game_time(const char* value) {
  set_has_game_time();
  if (game_time_ == &::google::protobuf::internal::kEmptyString) {
    game_time_ = new ::std::string;
  }
  game_time_->assign(value);
}
inline void GameInfo::set_game_time(const void* value, size_t size) {
  set_has_game_time();
  if (game_time_ == &::google::protobuf::internal::kEmptyString) {
    game_time_ = new ::std::string;
  }
  game_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_game_time() {
  set_has_game_time();
  if (game_time_ == &::google::protobuf::internal::kEmptyString) {
    game_time_ = new ::std::string;
  }
  return game_time_;
}
inline ::std::string* GameInfo::release_game_time() {
  clear_has_game_time();
  if (game_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = game_time_;
    game_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_game_time(::std::string* game_time) {
  if (game_time_ != &::google::protobuf::internal::kEmptyString) {
    delete game_time_;
  }
  if (game_time) {
    set_has_game_time();
    game_time_ = game_time;
  } else {
    clear_has_game_time();
    game_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ACKGetGameHistory

// required int32 player_id = 1;
inline bool ACKGetGameHistory::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKGetGameHistory::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKGetGameHistory::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKGetGameHistory::clear_player_id() {
  player_id_ = 0;
  clear_has_player_id();
}
inline ::google::protobuf::int32 ACKGetGameHistory::player_id() const {
  return player_id_;
}
inline void ACKGetGameHistory::set_player_id(::google::protobuf::int32 value) {
  set_has_player_id();
  player_id_ = value;
}

// repeated .GameInfo game_info_list = 2;
inline int ACKGetGameHistory::game_info_list_size() const {
  return game_info_list_.size();
}
inline void ACKGetGameHistory::clear_game_info_list() {
  game_info_list_.Clear();
}
inline const ::GameInfo& ACKGetGameHistory::game_info_list(int index) const {
  return game_info_list_.Get(index);
}
inline ::GameInfo* ACKGetGameHistory::mutable_game_info_list(int index) {
  return game_info_list_.Mutable(index);
}
inline ::GameInfo* ACKGetGameHistory::add_game_info_list() {
  return game_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GameInfo >&
ACKGetGameHistory::game_info_list() const {
  return game_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::GameInfo >*
ACKGetGameHistory::mutable_game_info_list() {
  return &game_info_list_;
}

// -------------------------------------------------------------------

// REQGetFriendInfo

// required bytes friend_name = 1;
inline bool REQGetFriendInfo::has_friend_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQGetFriendInfo::set_has_friend_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQGetFriendInfo::clear_has_friend_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQGetFriendInfo::clear_friend_name() {
  if (friend_name_ != &::google::protobuf::internal::kEmptyString) {
    friend_name_->clear();
  }
  clear_has_friend_name();
}
inline const ::std::string& REQGetFriendInfo::friend_name() const {
  return *friend_name_;
}
inline void REQGetFriendInfo::set_friend_name(const ::std::string& value) {
  set_has_friend_name();
  if (friend_name_ == &::google::protobuf::internal::kEmptyString) {
    friend_name_ = new ::std::string;
  }
  friend_name_->assign(value);
}
inline void REQGetFriendInfo::set_friend_name(const char* value) {
  set_has_friend_name();
  if (friend_name_ == &::google::protobuf::internal::kEmptyString) {
    friend_name_ = new ::std::string;
  }
  friend_name_->assign(value);
}
inline void REQGetFriendInfo::set_friend_name(const void* value, size_t size) {
  set_has_friend_name();
  if (friend_name_ == &::google::protobuf::internal::kEmptyString) {
    friend_name_ = new ::std::string;
  }
  friend_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQGetFriendInfo::mutable_friend_name() {
  set_has_friend_name();
  if (friend_name_ == &::google::protobuf::internal::kEmptyString) {
    friend_name_ = new ::std::string;
  }
  return friend_name_;
}
inline ::std::string* REQGetFriendInfo::release_friend_name() {
  clear_has_friend_name();
  if (friend_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = friend_name_;
    friend_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void REQGetFriendInfo::set_allocated_friend_name(::std::string* friend_name) {
  if (friend_name_ != &::google::protobuf::internal::kEmptyString) {
    delete friend_name_;
  }
  if (friend_name) {
    set_has_friend_name();
    friend_name_ = friend_name;
  } else {
    clear_has_friend_name();
    friend_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 user_id = 2;
inline bool REQGetFriendInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQGetFriendInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQGetFriendInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQGetFriendInfo::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQGetFriendInfo::user_id() const {
  return user_id_;
}
inline void REQGetFriendInfo::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// ACKGetFriendInfo

// required .UserInfo friendinfo = 1;
inline bool ACKGetFriendInfo::has_friendinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKGetFriendInfo::set_has_friendinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKGetFriendInfo::clear_has_friendinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKGetFriendInfo::clear_friendinfo() {
  if (friendinfo_ != NULL) friendinfo_->::UserInfo::Clear();
  clear_has_friendinfo();
}
inline const ::UserInfo& ACKGetFriendInfo::friendinfo() const {
  return friendinfo_ != NULL ? *friendinfo_ : *default_instance_->friendinfo_;
}
inline ::UserInfo* ACKGetFriendInfo::mutable_friendinfo() {
  set_has_friendinfo();
  if (friendinfo_ == NULL) friendinfo_ = new ::UserInfo;
  return friendinfo_;
}
inline ::UserInfo* ACKGetFriendInfo::release_friendinfo() {
  clear_has_friendinfo();
  ::UserInfo* temp = friendinfo_;
  friendinfo_ = NULL;
  return temp;
}
inline void ACKGetFriendInfo::set_allocated_friendinfo(::UserInfo* friendinfo) {
  delete friendinfo_;
  friendinfo_ = friendinfo;
  if (friendinfo) {
    set_has_friendinfo();
  } else {
    clear_has_friendinfo();
  }
}

// required bool is_my_friend = 2;
inline bool ACKGetFriendInfo::has_is_my_friend() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKGetFriendInfo::set_has_is_my_friend() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKGetFriendInfo::clear_has_is_my_friend() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKGetFriendInfo::clear_is_my_friend() {
  is_my_friend_ = false;
  clear_has_is_my_friend();
}
inline bool ACKGetFriendInfo::is_my_friend() const {
  return is_my_friend_;
}
inline void ACKGetFriendInfo::set_is_my_friend(bool value) {
  set_has_is_my_friend();
  is_my_friend_ = value;
}

// required bool is_exist = 3;
inline bool ACKGetFriendInfo::has_is_exist() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKGetFriendInfo::set_has_is_exist() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKGetFriendInfo::clear_has_is_exist() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKGetFriendInfo::clear_is_exist() {
  is_exist_ = false;
  clear_has_is_exist();
}
inline bool ACKGetFriendInfo::is_exist() const {
  return is_exist_;
}
inline void ACKGetFriendInfo::set_is_exist(bool value) {
  set_has_is_exist();
  is_exist_ = value;
}

// -------------------------------------------------------------------

// REQAddFriend

// required int32 friend_id = 1;
inline bool REQAddFriend::has_friend_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQAddFriend::set_has_friend_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQAddFriend::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQAddFriend::clear_friend_id() {
  friend_id_ = 0;
  clear_has_friend_id();
}
inline ::google::protobuf::int32 REQAddFriend::friend_id() const {
  return friend_id_;
}
inline void REQAddFriend::set_friend_id(::google::protobuf::int32 value) {
  set_has_friend_id();
  friend_id_ = value;
}

// required int32 user_id = 2;
inline bool REQAddFriend::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQAddFriend::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQAddFriend::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQAddFriend::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQAddFriend::user_id() const {
  return user_id_;
}
inline void REQAddFriend::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// ACKAddFriend

// required int32 code = 1;
inline bool ACKAddFriend::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKAddFriend::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKAddFriend::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKAddFriend::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKAddFriend::code() const {
  return code_;
}
inline void ACKAddFriend::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional bytes result_msg = 2;
inline bool ACKAddFriend::has_result_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKAddFriend::set_has_result_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKAddFriend::clear_has_result_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKAddFriend::clear_result_msg() {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    result_msg_->clear();
  }
  clear_has_result_msg();
}
inline const ::std::string& ACKAddFriend::result_msg() const {
  return *result_msg_;
}
inline void ACKAddFriend::set_result_msg(const ::std::string& value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKAddFriend::set_result_msg(const char* value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKAddFriend::set_result_msg(const void* value, size_t size) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKAddFriend::mutable_result_msg() {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  return result_msg_;
}
inline ::std::string* ACKAddFriend::release_result_msg() {
  clear_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_msg_;
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKAddFriend::set_allocated_result_msg(::std::string* result_msg) {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete result_msg_;
  }
  if (result_msg) {
    set_has_result_msg();
    result_msg_ = result_msg;
  } else {
    clear_has_result_msg();
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// REQRequestFriend

// required int32 num = 1;
inline bool REQRequestFriend::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQRequestFriend::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQRequestFriend::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQRequestFriend::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 REQRequestFriend::num() const {
  return num_;
}
inline void REQRequestFriend::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// required int32 user_id = 2;
inline bool REQRequestFriend::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQRequestFriend::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQRequestFriend::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQRequestFriend::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQRequestFriend::user_id() const {
  return user_id_;
}
inline void REQRequestFriend::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// REQIsAgreeFriend

// required int32 user_id = 1;
inline bool REQIsAgreeFriend::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQIsAgreeFriend::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQIsAgreeFriend::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQIsAgreeFriend::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQIsAgreeFriend::user_id() const {
  return user_id_;
}
inline void REQIsAgreeFriend::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 friend_id = 2;
inline bool REQIsAgreeFriend::has_friend_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQIsAgreeFriend::set_has_friend_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQIsAgreeFriend::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQIsAgreeFriend::clear_friend_id() {
  friend_id_ = 0;
  clear_has_friend_id();
}
inline ::google::protobuf::int32 REQIsAgreeFriend::friend_id() const {
  return friend_id_;
}
inline void REQIsAgreeFriend::set_friend_id(::google::protobuf::int32 value) {
  set_has_friend_id();
  friend_id_ = value;
}

// required bool is_agree = 3;
inline bool REQIsAgreeFriend::has_is_agree() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQIsAgreeFriend::set_has_is_agree() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQIsAgreeFriend::clear_has_is_agree() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQIsAgreeFriend::clear_is_agree() {
  is_agree_ = false;
  clear_has_is_agree();
}
inline bool REQIsAgreeFriend::is_agree() const {
  return is_agree_;
}
inline void REQIsAgreeFriend::set_is_agree(bool value) {
  set_has_is_agree();
  is_agree_ = value;
}

// -------------------------------------------------------------------

// ACKIsAgreeFriend

// required int32 code = 1;
inline bool ACKIsAgreeFriend::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKIsAgreeFriend::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKIsAgreeFriend::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKIsAgreeFriend::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKIsAgreeFriend::code() const {
  return code_;
}
inline void ACKIsAgreeFriend::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required bytes result_msg = 2;
inline bool ACKIsAgreeFriend::has_result_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKIsAgreeFriend::set_has_result_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKIsAgreeFriend::clear_has_result_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKIsAgreeFriend::clear_result_msg() {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    result_msg_->clear();
  }
  clear_has_result_msg();
}
inline const ::std::string& ACKIsAgreeFriend::result_msg() const {
  return *result_msg_;
}
inline void ACKIsAgreeFriend::set_result_msg(const ::std::string& value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKIsAgreeFriend::set_result_msg(const char* value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKIsAgreeFriend::set_result_msg(const void* value, size_t size) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKIsAgreeFriend::mutable_result_msg() {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  return result_msg_;
}
inline ::std::string* ACKIsAgreeFriend::release_result_msg() {
  clear_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_msg_;
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKIsAgreeFriend::set_allocated_result_msg(::std::string* result_msg) {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete result_msg_;
  }
  if (result_msg) {
    set_has_result_msg();
    result_msg_ = result_msg;
  } else {
    clear_has_result_msg();
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ACKUpdateFriend

// required int32 user_id = 1;
inline bool ACKUpdateFriend::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKUpdateFriend::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKUpdateFriend::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKUpdateFriend::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 ACKUpdateFriend::user_id() const {
  return user_id_;
}
inline void ACKUpdateFriend::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required .UserInfo firendinfo = 2;
inline bool ACKUpdateFriend::has_firendinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKUpdateFriend::set_has_firendinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKUpdateFriend::clear_has_firendinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKUpdateFriend::clear_firendinfo() {
  if (firendinfo_ != NULL) firendinfo_->::UserInfo::Clear();
  clear_has_firendinfo();
}
inline const ::UserInfo& ACKUpdateFriend::firendinfo() const {
  return firendinfo_ != NULL ? *firendinfo_ : *default_instance_->firendinfo_;
}
inline ::UserInfo* ACKUpdateFriend::mutable_firendinfo() {
  set_has_firendinfo();
  if (firendinfo_ == NULL) firendinfo_ = new ::UserInfo;
  return firendinfo_;
}
inline ::UserInfo* ACKUpdateFriend::release_firendinfo() {
  clear_has_firendinfo();
  ::UserInfo* temp = firendinfo_;
  firendinfo_ = NULL;
  return temp;
}
inline void ACKUpdateFriend::set_allocated_firendinfo(::UserInfo* firendinfo) {
  delete firendinfo_;
  firendinfo_ = firendinfo;
  if (firendinfo) {
    set_has_firendinfo();
  } else {
    clear_has_firendinfo();
  }
}

// -------------------------------------------------------------------

// REQFriendsList

// required int32 user_id = 1;
inline bool REQFriendsList::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQFriendsList::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQFriendsList::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQFriendsList::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQFriendsList::user_id() const {
  return user_id_;
}
inline void REQFriendsList::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// ACKFriendsList

// repeated .UserInfo firendinfo = 1;
inline int ACKFriendsList::firendinfo_size() const {
  return firendinfo_.size();
}
inline void ACKFriendsList::clear_firendinfo() {
  firendinfo_.Clear();
}
inline const ::UserInfo& ACKFriendsList::firendinfo(int index) const {
  return firendinfo_.Get(index);
}
inline ::UserInfo* ACKFriendsList::mutable_firendinfo(int index) {
  return firendinfo_.Mutable(index);
}
inline ::UserInfo* ACKFriendsList::add_firendinfo() {
  return firendinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UserInfo >&
ACKFriendsList::firendinfo() const {
  return firendinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::UserInfo >*
ACKFriendsList::mutable_firendinfo() {
  return &firendinfo_;
}

// -------------------------------------------------------------------

// REQWaitFriendsList

// required int32 user_id = 1;
inline bool REQWaitFriendsList::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQWaitFriendsList::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQWaitFriendsList::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQWaitFriendsList::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQWaitFriendsList::user_id() const {
  return user_id_;
}
inline void REQWaitFriendsList::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// ACKWaitFriendsList

// repeated .UserInfo firendinfo = 1;
inline int ACKWaitFriendsList::firendinfo_size() const {
  return firendinfo_.size();
}
inline void ACKWaitFriendsList::clear_firendinfo() {
  firendinfo_.Clear();
}
inline const ::UserInfo& ACKWaitFriendsList::firendinfo(int index) const {
  return firendinfo_.Get(index);
}
inline ::UserInfo* ACKWaitFriendsList::mutable_firendinfo(int index) {
  return firendinfo_.Mutable(index);
}
inline ::UserInfo* ACKWaitFriendsList::add_firendinfo() {
  return firendinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UserInfo >&
ACKWaitFriendsList::firendinfo() const {
  return firendinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::UserInfo >*
ACKWaitFriendsList::mutable_firendinfo() {
  return &firendinfo_;
}

// repeated bytes times = 2;
inline int ACKWaitFriendsList::times_size() const {
  return times_.size();
}
inline void ACKWaitFriendsList::clear_times() {
  times_.Clear();
}
inline const ::std::string& ACKWaitFriendsList::times(int index) const {
  return times_.Get(index);
}
inline ::std::string* ACKWaitFriendsList::mutable_times(int index) {
  return times_.Mutable(index);
}
inline void ACKWaitFriendsList::set_times(int index, const ::std::string& value) {
  times_.Mutable(index)->assign(value);
}
inline void ACKWaitFriendsList::set_times(int index, const char* value) {
  times_.Mutable(index)->assign(value);
}
inline void ACKWaitFriendsList::set_times(int index, const void* value, size_t size) {
  times_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKWaitFriendsList::add_times() {
  return times_.Add();
}
inline void ACKWaitFriendsList::add_times(const ::std::string& value) {
  times_.Add()->assign(value);
}
inline void ACKWaitFriendsList::add_times(const char* value) {
  times_.Add()->assign(value);
}
inline void ACKWaitFriendsList::add_times(const void* value, size_t size) {
  times_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ACKWaitFriendsList::times() const {
  return times_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ACKWaitFriendsList::mutable_times() {
  return &times_;
}

// -------------------------------------------------------------------

// REQDeleteFriend

// required int32 friend_id = 1;
inline bool REQDeleteFriend::has_friend_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQDeleteFriend::set_has_friend_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQDeleteFriend::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQDeleteFriend::clear_friend_id() {
  friend_id_ = 0;
  clear_has_friend_id();
}
inline ::google::protobuf::int32 REQDeleteFriend::friend_id() const {
  return friend_id_;
}
inline void REQDeleteFriend::set_friend_id(::google::protobuf::int32 value) {
  set_has_friend_id();
  friend_id_ = value;
}

// required int32 user_id = 2;
inline bool REQDeleteFriend::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQDeleteFriend::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQDeleteFriend::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQDeleteFriend::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQDeleteFriend::user_id() const {
  return user_id_;
}
inline void REQDeleteFriend::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// ACKDeleteFriend

// required int32 code = 1;
inline bool ACKDeleteFriend::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKDeleteFriend::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKDeleteFriend::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKDeleteFriend::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKDeleteFriend::code() const {
  return code_;
}
inline void ACKDeleteFriend::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional bytes result_msg = 2;
inline bool ACKDeleteFriend::has_result_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKDeleteFriend::set_has_result_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKDeleteFriend::clear_has_result_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKDeleteFriend::clear_result_msg() {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    result_msg_->clear();
  }
  clear_has_result_msg();
}
inline const ::std::string& ACKDeleteFriend::result_msg() const {
  return *result_msg_;
}
inline void ACKDeleteFriend::set_result_msg(const ::std::string& value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKDeleteFriend::set_result_msg(const char* value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKDeleteFriend::set_result_msg(const void* value, size_t size) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKDeleteFriend::mutable_result_msg() {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  return result_msg_;
}
inline ::std::string* ACKDeleteFriend::release_result_msg() {
  clear_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_msg_;
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKDeleteFriend::set_allocated_result_msg(::std::string* result_msg) {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete result_msg_;
  }
  if (result_msg) {
    set_has_result_msg();
    result_msg_ = result_msg;
  } else {
    clear_has_result_msg();
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// REQBuy

// required int32 user_id = 1;
inline bool REQBuy::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQBuy::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQBuy::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQBuy::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQBuy::user_id() const {
  return user_id_;
}
inline void REQBuy::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 item_id = 2;
inline bool REQBuy::has_item_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQBuy::set_has_item_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQBuy::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQBuy::clear_item_id() {
  item_id_ = 0;
  clear_has_item_id();
}
inline ::google::protobuf::int32 REQBuy::item_id() const {
  return item_id_;
}
inline void REQBuy::set_item_id(::google::protobuf::int32 value) {
  set_has_item_id();
  item_id_ = value;
}

// required int32 price = 3;
inline bool REQBuy::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQBuy::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQBuy::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQBuy::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 REQBuy::price() const {
  return price_;
}
inline void REQBuy::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// required int32 num = 4;
inline bool REQBuy::has_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void REQBuy::set_has_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void REQBuy::clear_has_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void REQBuy::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 REQBuy::num() const {
  return num_;
}
inline void REQBuy::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// ACKBuy

// required int32 code = 1;
inline bool ACKBuy::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKBuy::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKBuy::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKBuy::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKBuy::code() const {
  return code_;
}
inline void ACKBuy::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required bytes result_msg = 2;
inline bool ACKBuy::has_result_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKBuy::set_has_result_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKBuy::clear_has_result_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKBuy::clear_result_msg() {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    result_msg_->clear();
  }
  clear_has_result_msg();
}
inline const ::std::string& ACKBuy::result_msg() const {
  return *result_msg_;
}
inline void ACKBuy::set_result_msg(const ::std::string& value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKBuy::set_result_msg(const char* value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKBuy::set_result_msg(const void* value, size_t size) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKBuy::mutable_result_msg() {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  return result_msg_;
}
inline ::std::string* ACKBuy::release_result_msg() {
  clear_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_msg_;
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKBuy::set_allocated_result_msg(::std::string* result_msg) {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete result_msg_;
  }
  if (result_msg) {
    set_has_result_msg();
    result_msg_ = result_msg;
  } else {
    clear_has_result_msg();
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 item_id = 3;
inline bool ACKBuy::has_item_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKBuy::set_has_item_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKBuy::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKBuy::clear_item_id() {
  item_id_ = 0;
  clear_has_item_id();
}
inline ::google::protobuf::int32 ACKBuy::item_id() const {
  return item_id_;
}
inline void ACKBuy::set_item_id(::google::protobuf::int32 value) {
  set_has_item_id();
  item_id_ = value;
}

// optional int32 price = 4;
inline bool ACKBuy::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACKBuy::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACKBuy::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACKBuy::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 ACKBuy::price() const {
  return price_;
}
inline void ACKBuy::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// optional int32 num = 5;
inline bool ACKBuy::has_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ACKBuy::set_has_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ACKBuy::clear_has_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ACKBuy::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 ACKBuy::num() const {
  return num_;
}
inline void ACKBuy::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_wzqProtocol_2eproto__INCLUDED
