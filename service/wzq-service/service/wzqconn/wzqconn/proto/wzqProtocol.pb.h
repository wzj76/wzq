// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: wzqProtocol.proto

#ifndef PROTOBUF_wzqProtocol_2eproto__INCLUDED
#define PROTOBUF_wzqProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_wzqProtocol_2eproto();
void protobuf_AssignDesc_wzqProtocol_2eproto();
void protobuf_ShutdownFile_wzqProtocol_2eproto();

class REQHold;
class ACKHold;
class MsgPackage;
class REQRegister;
class ACKRegister;
class REQLogin;
class ACKLogin;
class UserInfo;
class UserInfo_Prop;
class REQRoom;
class ACKRoom;
class REQEditHead;
class ACKEditHead;
class REQForcExit;
class REQExitAccount;
class REQRequestFriend;
class ACKUpdateFriend;
class REQContinueGame;
class ACKContinueGame;
class REQAskContinueGame;
class ACKAskContinueGame;
class ACKRefuseContinueGame;
class ACKFriendsList;
class REQExitGame;
class ACKExitGame;
class REQInviteFriendGame;
class ACKInviteFriendGame;
class REQAskInviteFriendGame;
class ACKAskInviteFriendGame;
class ACKRefuseInviteFriendGame;

// ===================================================================

class REQHold : public ::google::protobuf::Message {
 public:
  REQHold();
  virtual ~REQHold();

  REQHold(const REQHold& from);

  inline REQHold& operator=(const REQHold& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQHold& default_instance();

  void Swap(REQHold* other);

  // implements Message ----------------------------------------------

  REQHold* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQHold& from);
  void MergeFrom(const REQHold& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:REQHold)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQHold* default_instance_;
};
// -------------------------------------------------------------------

class ACKHold : public ::google::protobuf::Message {
 public:
  ACKHold();
  virtual ~ACKHold();

  ACKHold(const ACKHold& from);

  inline ACKHold& operator=(const ACKHold& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKHold& default_instance();

  void Swap(ACKHold* other);

  // implements Message ----------------------------------------------

  ACKHold* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKHold& from);
  void MergeFrom(const ACKHold& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result_id = 1;
  inline bool has_result_id() const;
  inline void clear_result_id();
  static const int kResultIdFieldNumber = 1;
  inline ::google::protobuf::int32 result_id() const;
  inline void set_result_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ACKHold)
 private:
  inline void set_has_result_id();
  inline void clear_has_result_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKHold* default_instance_;
};
// -------------------------------------------------------------------

class MsgPackage : public ::google::protobuf::Message {
 public:
  MsgPackage();
  virtual ~MsgPackage();

  MsgPackage(const MsgPackage& from);

  inline MsgPackage& operator=(const MsgPackage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPackage& default_instance();

  void Swap(MsgPackage* other);

  // implements Message ----------------------------------------------

  MsgPackage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgPackage& from);
  void MergeFrom(const MsgPackage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 msg_id = 1;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  inline ::google::protobuf::int64 msg_id() const;
  inline void set_msg_id(::google::protobuf::int64 value);

  // optional int64 seq_id = 2;
  inline bool has_seq_id() const;
  inline void clear_seq_id();
  static const int kSeqIdFieldNumber = 2;
  inline ::google::protobuf::int64 seq_id() const;
  inline void set_seq_id(::google::protobuf::int64 value);

  // optional int64 user_id = 3;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  inline ::google::protobuf::int64 user_id() const;
  inline void set_user_id(::google::protobuf::int64 value);

  // optional bytes msg = 4;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 4;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const void* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // optional bytes src = 5;
  inline bool has_src() const;
  inline void clear_src();
  static const int kSrcFieldNumber = 5;
  inline const ::std::string& src() const;
  inline void set_src(const ::std::string& value);
  inline void set_src(const char* value);
  inline void set_src(const void* value, size_t size);
  inline ::std::string* mutable_src();
  inline ::std::string* release_src();
  inline void set_allocated_src(::std::string* src);

  // optional int64 clientid = 6;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientidFieldNumber = 6;
  inline ::google::protobuf::int64 clientid() const;
  inline void set_clientid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:MsgPackage)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_seq_id();
  inline void clear_has_seq_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_src();
  inline void clear_has_src();
  inline void set_has_clientid();
  inline void clear_has_clientid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 msg_id_;
  ::google::protobuf::int64 seq_id_;
  ::google::protobuf::int64 user_id_;
  ::std::string* msg_;
  ::std::string* src_;
  ::google::protobuf::int64 clientid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static MsgPackage* default_instance_;
};
// -------------------------------------------------------------------

class REQRegister : public ::google::protobuf::Message {
 public:
  REQRegister();
  virtual ~REQRegister();

  REQRegister(const REQRegister& from);

  inline REQRegister& operator=(const REQRegister& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQRegister& default_instance();

  void Swap(REQRegister* other);

  // implements Message ----------------------------------------------

  REQRegister* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQRegister& from);
  void MergeFrom(const REQRegister& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const void* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional bytes passwd = 2;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 2;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const void* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  inline void set_allocated_passwd(::std::string* passwd);

  // @@protoc_insertion_point(class_scope:REQRegister)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_passwd();
  inline void clear_has_passwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* passwd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQRegister* default_instance_;
};
// -------------------------------------------------------------------

class ACKRegister : public ::google::protobuf::Message {
 public:
  ACKRegister();
  virtual ~ACKRegister();

  ACKRegister(const ACKRegister& from);

  inline ACKRegister& operator=(const ACKRegister& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKRegister& default_instance();

  void Swap(ACKRegister* other);

  // implements Message ----------------------------------------------

  ACKRegister* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKRegister& from);
  void MergeFrom(const ACKRegister& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional bytes result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const void* value, size_t size);
  inline ::std::string* mutable_result();
  inline ::std::string* release_result();
  inline void set_allocated_result(::std::string* result);

  // @@protoc_insertion_point(class_scope:ACKRegister)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKRegister* default_instance_;
};
// -------------------------------------------------------------------

class REQLogin : public ::google::protobuf::Message {
 public:
  REQLogin();
  virtual ~REQLogin();

  REQLogin(const REQLogin& from);

  inline REQLogin& operator=(const REQLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQLogin& default_instance();

  void Swap(REQLogin* other);

  // implements Message ----------------------------------------------

  REQLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQLogin& from);
  void MergeFrom(const REQLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const void* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional bytes passwd = 2;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 2;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const void* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  inline void set_allocated_passwd(::std::string* passwd);

  // @@protoc_insertion_point(class_scope:REQLogin)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_passwd();
  inline void clear_has_passwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* passwd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQLogin* default_instance_;
};
// -------------------------------------------------------------------

class ACKLogin : public ::google::protobuf::Message {
 public:
  ACKLogin();
  virtual ~ACKLogin();

  ACKLogin(const ACKLogin& from);

  inline ACKLogin& operator=(const ACKLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKLogin& default_instance();

  void Swap(ACKLogin* other);

  // implements Message ----------------------------------------------

  ACKLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKLogin& from);
  void MergeFrom(const ACKLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional .UserInfo userinfo = 2;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserinfoFieldNumber = 2;
  inline const ::UserInfo& userinfo() const;
  inline ::UserInfo* mutable_userinfo();
  inline ::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::UserInfo* userinfo);

  // @@protoc_insertion_point(class_scope:ACKLogin)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserInfo* userinfo_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKLogin* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo_Prop : public ::google::protobuf::Message {
 public:
  UserInfo_Prop();
  virtual ~UserInfo_Prop();

  UserInfo_Prop(const UserInfo_Prop& from);

  inline UserInfo_Prop& operator=(const UserInfo_Prop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo_Prop& default_instance();

  void Swap(UserInfo_Prop* other);

  // implements Message ----------------------------------------------

  UserInfo_Prop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo_Prop& from);
  void MergeFrom(const UserInfo_Prop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 quantity = 2;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  inline ::google::protobuf::int32 quantity() const;
  inline void set_quantity(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UserInfo.Prop)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_quantity();
  inline void clear_has_quantity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 quantity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static UserInfo_Prop* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UserInfo_Prop Prop;

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional bytes username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const void* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional int32 wintimes = 3;
  inline bool has_wintimes() const;
  inline void clear_wintimes();
  static const int kWintimesFieldNumber = 3;
  inline ::google::protobuf::int32 wintimes() const;
  inline void set_wintimes(::google::protobuf::int32 value);

  // optional int32 losetimes = 4;
  inline bool has_losetimes() const;
  inline void clear_losetimes();
  static const int kLosetimesFieldNumber = 4;
  inline ::google::protobuf::int32 losetimes() const;
  inline void set_losetimes(::google::protobuf::int32 value);

  // optional int32 score = 5;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 5;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // optional int32 level = 6;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 6;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 xp = 7;
  inline bool has_xp() const;
  inline void clear_xp();
  static const int kXpFieldNumber = 7;
  inline ::google::protobuf::int32 xp() const;
  inline void set_xp(::google::protobuf::int32 value);

  // optional int32 head_id = 8;
  inline bool has_head_id() const;
  inline void clear_head_id();
  static const int kHeadIdFieldNumber = 8;
  inline ::google::protobuf::int32 head_id() const;
  inline void set_head_id(::google::protobuf::int32 value);

  // optional bool is_online = 9;
  inline bool has_is_online() const;
  inline void clear_is_online();
  static const int kIsOnlineFieldNumber = 9;
  inline bool is_online() const;
  inline void set_is_online(bool value);

  // optional int32 coins = 10;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 10;
  inline ::google::protobuf::int32 coins() const;
  inline void set_coins(::google::protobuf::int32 value);

  // repeated .UserInfo.Prop props = 11;
  inline int props_size() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 11;
  inline const ::UserInfo_Prop& props(int index) const;
  inline ::UserInfo_Prop* mutable_props(int index);
  inline ::UserInfo_Prop* add_props();
  inline const ::google::protobuf::RepeatedPtrField< ::UserInfo_Prop >&
      props() const;
  inline ::google::protobuf::RepeatedPtrField< ::UserInfo_Prop >*
      mutable_props();

  // @@protoc_insertion_point(class_scope:UserInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_wintimes();
  inline void clear_has_wintimes();
  inline void set_has_losetimes();
  inline void clear_has_losetimes();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_xp();
  inline void clear_has_xp();
  inline void set_has_head_id();
  inline void clear_has_head_id();
  inline void set_has_is_online();
  inline void clear_has_is_online();
  inline void set_has_coins();
  inline void clear_has_coins();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 wintimes_;
  ::google::protobuf::int32 losetimes_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 xp_;
  ::google::protobuf::int32 head_id_;
  bool is_online_;
  ::google::protobuf::RepeatedPtrField< ::UserInfo_Prop > props_;
  ::google::protobuf::int32 coins_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class REQRoom : public ::google::protobuf::Message {
 public:
  REQRoom();
  virtual ~REQRoom();

  REQRoom(const REQRoom& from);

  inline REQRoom& operator=(const REQRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQRoom& default_instance();

  void Swap(REQRoom* other);

  // implements Message ----------------------------------------------

  REQRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQRoom& from);
  void MergeFrom(const REQRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes req_msg = 1;
  inline bool has_req_msg() const;
  inline void clear_req_msg();
  static const int kReqMsgFieldNumber = 1;
  inline const ::std::string& req_msg() const;
  inline void set_req_msg(const ::std::string& value);
  inline void set_req_msg(const char* value);
  inline void set_req_msg(const void* value, size_t size);
  inline ::std::string* mutable_req_msg();
  inline ::std::string* release_req_msg();
  inline void set_allocated_req_msg(::std::string* req_msg);

  // required .UserInfo userinfo = 2;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserinfoFieldNumber = 2;
  inline const ::UserInfo& userinfo() const;
  inline ::UserInfo* mutable_userinfo();
  inline ::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::UserInfo* userinfo);

  // @@protoc_insertion_point(class_scope:REQRoom)
 private:
  inline void set_has_req_msg();
  inline void clear_has_req_msg();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* req_msg_;
  ::UserInfo* userinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQRoom* default_instance_;
};
// -------------------------------------------------------------------

class ACKRoom : public ::google::protobuf::Message {
 public:
  ACKRoom();
  virtual ~ACKRoom();

  ACKRoom(const ACKRoom& from);

  inline ACKRoom& operator=(const ACKRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKRoom& default_instance();

  void Swap(ACKRoom* other);

  // implements Message ----------------------------------------------

  ACKRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKRoom& from);
  void MergeFrom(const ACKRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional bytes result_msg = 2;
  inline bool has_result_msg() const;
  inline void clear_result_msg();
  static const int kResultMsgFieldNumber = 2;
  inline const ::std::string& result_msg() const;
  inline void set_result_msg(const ::std::string& value);
  inline void set_result_msg(const char* value);
  inline void set_result_msg(const void* value, size_t size);
  inline ::std::string* mutable_result_msg();
  inline ::std::string* release_result_msg();
  inline void set_allocated_result_msg(::std::string* result_msg);

  // required .UserInfo userinfo = 3;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserinfoFieldNumber = 3;
  inline const ::UserInfo& userinfo() const;
  inline ::UserInfo* mutable_userinfo();
  inline ::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::UserInfo* userinfo);

  // required int32 black_id = 4;
  inline bool has_black_id() const;
  inline void clear_black_id();
  static const int kBlackIdFieldNumber = 4;
  inline ::google::protobuf::int32 black_id() const;
  inline void set_black_id(::google::protobuf::int32 value);

  // required int32 white_id = 5;
  inline bool has_white_id() const;
  inline void clear_white_id();
  static const int kWhiteIdFieldNumber = 5;
  inline ::google::protobuf::int32 white_id() const;
  inline void set_white_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ACKRoom)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_result_msg();
  inline void clear_has_result_msg();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  inline void set_has_black_id();
  inline void clear_has_black_id();
  inline void set_has_white_id();
  inline void clear_has_white_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_msg_;
  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 black_id_;
  ::UserInfo* userinfo_;
  ::google::protobuf::int32 white_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKRoom* default_instance_;
};
// -------------------------------------------------------------------

class REQEditHead : public ::google::protobuf::Message {
 public:
  REQEditHead();
  virtual ~REQEditHead();

  REQEditHead(const REQEditHead& from);

  inline REQEditHead& operator=(const REQEditHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQEditHead& default_instance();

  void Swap(REQEditHead* other);

  // implements Message ----------------------------------------------

  REQEditHead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQEditHead& from);
  void MergeFrom(const REQEditHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 head_num = 1;
  inline bool has_head_num() const;
  inline void clear_head_num();
  static const int kHeadNumFieldNumber = 1;
  inline ::google::protobuf::int32 head_num() const;
  inline void set_head_num(::google::protobuf::int32 value);

  // optional bytes user_name = 2;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const void* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // @@protoc_insertion_point(class_scope:REQEditHead)
 private:
  inline void set_has_head_num();
  inline void clear_has_head_num();
  inline void set_has_user_name();
  inline void clear_has_user_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_name_;
  ::google::protobuf::int32 head_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQEditHead* default_instance_;
};
// -------------------------------------------------------------------

class ACKEditHead : public ::google::protobuf::Message {
 public:
  ACKEditHead();
  virtual ~ACKEditHead();

  ACKEditHead(const ACKEditHead& from);

  inline ACKEditHead& operator=(const ACKEditHead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKEditHead& default_instance();

  void Swap(ACKEditHead* other);

  // implements Message ----------------------------------------------

  ACKEditHead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKEditHead& from);
  void MergeFrom(const ACKEditHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ACKEditHead)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKEditHead* default_instance_;
};
// -------------------------------------------------------------------

class REQForcExit : public ::google::protobuf::Message {
 public:
  REQForcExit();
  virtual ~REQForcExit();

  REQForcExit(const REQForcExit& from);

  inline REQForcExit& operator=(const REQForcExit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQForcExit& default_instance();

  void Swap(REQForcExit* other);

  // implements Message ----------------------------------------------

  REQForcExit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQForcExit& from);
  void MergeFrom(const REQForcExit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQForcExit)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQForcExit* default_instance_;
};
// -------------------------------------------------------------------

class REQExitAccount : public ::google::protobuf::Message {
 public:
  REQExitAccount();
  virtual ~REQExitAccount();

  REQExitAccount(const REQExitAccount& from);

  inline REQExitAccount& operator=(const REQExitAccount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQExitAccount& default_instance();

  void Swap(REQExitAccount* other);

  // implements Message ----------------------------------------------

  REQExitAccount* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQExitAccount& from);
  void MergeFrom(const REQExitAccount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQExitAccount)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQExitAccount* default_instance_;
};
// -------------------------------------------------------------------

class REQRequestFriend : public ::google::protobuf::Message {
 public:
  REQRequestFriend();
  virtual ~REQRequestFriend();

  REQRequestFriend(const REQRequestFriend& from);

  inline REQRequestFriend& operator=(const REQRequestFriend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQRequestFriend& default_instance();

  void Swap(REQRequestFriend* other);

  // implements Message ----------------------------------------------

  REQRequestFriend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQRequestFriend& from);
  void MergeFrom(const REQRequestFriend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 num = 1;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 1;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // required int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQRequestFriend)
 private:
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQRequestFriend* default_instance_;
};
// -------------------------------------------------------------------

class ACKUpdateFriend : public ::google::protobuf::Message {
 public:
  ACKUpdateFriend();
  virtual ~ACKUpdateFriend();

  ACKUpdateFriend(const ACKUpdateFriend& from);

  inline ACKUpdateFriend& operator=(const ACKUpdateFriend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKUpdateFriend& default_instance();

  void Swap(ACKUpdateFriend* other);

  // implements Message ----------------------------------------------

  ACKUpdateFriend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKUpdateFriend& from);
  void MergeFrom(const ACKUpdateFriend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required .UserInfo firendinfo = 2;
  inline bool has_firendinfo() const;
  inline void clear_firendinfo();
  static const int kFirendinfoFieldNumber = 2;
  inline const ::UserInfo& firendinfo() const;
  inline ::UserInfo* mutable_firendinfo();
  inline ::UserInfo* release_firendinfo();
  inline void set_allocated_firendinfo(::UserInfo* firendinfo);

  // @@protoc_insertion_point(class_scope:ACKUpdateFriend)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_firendinfo();
  inline void clear_has_firendinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserInfo* firendinfo_;
  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKUpdateFriend* default_instance_;
};
// -------------------------------------------------------------------

class REQContinueGame : public ::google::protobuf::Message {
 public:
  REQContinueGame();
  virtual ~REQContinueGame();

  REQContinueGame(const REQContinueGame& from);

  inline REQContinueGame& operator=(const REQContinueGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQContinueGame& default_instance();

  void Swap(REQContinueGame* other);

  // implements Message ----------------------------------------------

  REQContinueGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQContinueGame& from);
  void MergeFrom(const REQContinueGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 enemy_user_id = 2;
  inline bool has_enemy_user_id() const;
  inline void clear_enemy_user_id();
  static const int kEnemyUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 enemy_user_id() const;
  inline void set_enemy_user_id(::google::protobuf::int32 value);

  // required int32 table_id = 3;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  inline ::google::protobuf::int32 table_id() const;
  inline void set_table_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQContinueGame)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_enemy_user_id();
  inline void clear_has_enemy_user_id();
  inline void set_has_table_id();
  inline void clear_has_table_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 enemy_user_id_;
  ::google::protobuf::int32 table_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQContinueGame* default_instance_;
};
// -------------------------------------------------------------------

class ACKContinueGame : public ::google::protobuf::Message {
 public:
  ACKContinueGame();
  virtual ~ACKContinueGame();

  ACKContinueGame(const ACKContinueGame& from);

  inline ACKContinueGame& operator=(const ACKContinueGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKContinueGame& default_instance();

  void Swap(ACKContinueGame* other);

  // implements Message ----------------------------------------------

  ACKContinueGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKContinueGame& from);
  void MergeFrom(const ACKContinueGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required bytes result_msg = 2;
  inline bool has_result_msg() const;
  inline void clear_result_msg();
  static const int kResultMsgFieldNumber = 2;
  inline const ::std::string& result_msg() const;
  inline void set_result_msg(const ::std::string& value);
  inline void set_result_msg(const char* value);
  inline void set_result_msg(const void* value, size_t size);
  inline ::std::string* mutable_result_msg();
  inline ::std::string* release_result_msg();
  inline void set_allocated_result_msg(::std::string* result_msg);

  // @@protoc_insertion_point(class_scope:ACKContinueGame)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_result_msg();
  inline void clear_has_result_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_msg_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKContinueGame* default_instance_;
};
// -------------------------------------------------------------------

class REQAskContinueGame : public ::google::protobuf::Message {
 public:
  REQAskContinueGame();
  virtual ~REQAskContinueGame();

  REQAskContinueGame(const REQAskContinueGame& from);

  inline REQAskContinueGame& operator=(const REQAskContinueGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQAskContinueGame& default_instance();

  void Swap(REQAskContinueGame* other);

  // implements Message ----------------------------------------------

  REQAskContinueGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQAskContinueGame& from);
  void MergeFrom(const REQAskContinueGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 enemy_user_id = 1;
  inline bool has_enemy_user_id() const;
  inline void clear_enemy_user_id();
  static const int kEnemyUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 enemy_user_id() const;
  inline void set_enemy_user_id(::google::protobuf::int32 value);

  // required int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 table_id = 3;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 3;
  inline ::google::protobuf::int32 table_id() const;
  inline void set_table_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQAskContinueGame)
 private:
  inline void set_has_enemy_user_id();
  inline void clear_has_enemy_user_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_table_id();
  inline void clear_has_table_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 enemy_user_id_;
  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 table_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQAskContinueGame* default_instance_;
};
// -------------------------------------------------------------------

class ACKAskContinueGame : public ::google::protobuf::Message {
 public:
  ACKAskContinueGame();
  virtual ~ACKAskContinueGame();

  ACKAskContinueGame(const ACKAskContinueGame& from);

  inline ACKAskContinueGame& operator=(const ACKAskContinueGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKAskContinueGame& default_instance();

  void Swap(ACKAskContinueGame* other);

  // implements Message ----------------------------------------------

  ACKAskContinueGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKAskContinueGame& from);
  void MergeFrom(const ACKAskContinueGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_agree_continue_game = 1;
  inline bool has_is_agree_continue_game() const;
  inline void clear_is_agree_continue_game();
  static const int kIsAgreeContinueGameFieldNumber = 1;
  inline bool is_agree_continue_game() const;
  inline void set_is_agree_continue_game(bool value);

  // required int32 enemy_user_id = 2;
  inline bool has_enemy_user_id() const;
  inline void clear_enemy_user_id();
  static const int kEnemyUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 enemy_user_id() const;
  inline void set_enemy_user_id(::google::protobuf::int32 value);

  // required int32 user_id = 3;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 table_id = 4;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 4;
  inline ::google::protobuf::int32 table_id() const;
  inline void set_table_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ACKAskContinueGame)
 private:
  inline void set_has_is_agree_continue_game();
  inline void clear_has_is_agree_continue_game();
  inline void set_has_enemy_user_id();
  inline void clear_has_enemy_user_id();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_table_id();
  inline void clear_has_table_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_agree_continue_game_;
  ::google::protobuf::int32 enemy_user_id_;
  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 table_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKAskContinueGame* default_instance_;
};
// -------------------------------------------------------------------

class ACKRefuseContinueGame : public ::google::protobuf::Message {
 public:
  ACKRefuseContinueGame();
  virtual ~ACKRefuseContinueGame();

  ACKRefuseContinueGame(const ACKRefuseContinueGame& from);

  inline ACKRefuseContinueGame& operator=(const ACKRefuseContinueGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKRefuseContinueGame& default_instance();

  void Swap(ACKRefuseContinueGame* other);

  // implements Message ----------------------------------------------

  ACKRefuseContinueGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKRefuseContinueGame& from);
  void MergeFrom(const ACKRefuseContinueGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required bytes result_msg = 2;
  inline bool has_result_msg() const;
  inline void clear_result_msg();
  static const int kResultMsgFieldNumber = 2;
  inline const ::std::string& result_msg() const;
  inline void set_result_msg(const ::std::string& value);
  inline void set_result_msg(const char* value);
  inline void set_result_msg(const void* value, size_t size);
  inline ::std::string* mutable_result_msg();
  inline ::std::string* release_result_msg();
  inline void set_allocated_result_msg(::std::string* result_msg);

  // @@protoc_insertion_point(class_scope:ACKRefuseContinueGame)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_result_msg();
  inline void clear_has_result_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_msg_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKRefuseContinueGame* default_instance_;
};
// -------------------------------------------------------------------

class ACKFriendsList : public ::google::protobuf::Message {
 public:
  ACKFriendsList();
  virtual ~ACKFriendsList();

  ACKFriendsList(const ACKFriendsList& from);

  inline ACKFriendsList& operator=(const ACKFriendsList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKFriendsList& default_instance();

  void Swap(ACKFriendsList* other);

  // implements Message ----------------------------------------------

  ACKFriendsList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKFriendsList& from);
  void MergeFrom(const ACKFriendsList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .UserInfo firendinfo = 1;
  inline int firendinfo_size() const;
  inline void clear_firendinfo();
  static const int kFirendinfoFieldNumber = 1;
  inline const ::UserInfo& firendinfo(int index) const;
  inline ::UserInfo* mutable_firendinfo(int index);
  inline ::UserInfo* add_firendinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::UserInfo >&
      firendinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::UserInfo >*
      mutable_firendinfo();

  // @@protoc_insertion_point(class_scope:ACKFriendsList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::UserInfo > firendinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKFriendsList* default_instance_;
};
// -------------------------------------------------------------------

class REQExitGame : public ::google::protobuf::Message {
 public:
  REQExitGame();
  virtual ~REQExitGame();

  REQExitGame(const REQExitGame& from);

  inline REQExitGame& operator=(const REQExitGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQExitGame& default_instance();

  void Swap(REQExitGame* other);

  // implements Message ----------------------------------------------

  REQExitGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQExitGame& from);
  void MergeFrom(const REQExitGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes req_msg = 1;
  inline bool has_req_msg() const;
  inline void clear_req_msg();
  static const int kReqMsgFieldNumber = 1;
  inline const ::std::string& req_msg() const;
  inline void set_req_msg(const ::std::string& value);
  inline void set_req_msg(const char* value);
  inline void set_req_msg(const void* value, size_t size);
  inline ::std::string* mutable_req_msg();
  inline ::std::string* release_req_msg();
  inline void set_allocated_req_msg(::std::string* req_msg);

  // optional int32 exit_table_id = 2;
  inline bool has_exit_table_id() const;
  inline void clear_exit_table_id();
  static const int kExitTableIdFieldNumber = 2;
  inline ::google::protobuf::int32 exit_table_id() const;
  inline void set_exit_table_id(::google::protobuf::int32 value);

  // required int32 exit_user_id = 3;
  inline bool has_exit_user_id() const;
  inline void clear_exit_user_id();
  static const int kExitUserIdFieldNumber = 3;
  inline ::google::protobuf::int32 exit_user_id() const;
  inline void set_exit_user_id(::google::protobuf::int32 value);

  // required int32 enemy_user_id = 4;
  inline bool has_enemy_user_id() const;
  inline void clear_enemy_user_id();
  static const int kEnemyUserIdFieldNumber = 4;
  inline ::google::protobuf::int32 enemy_user_id() const;
  inline void set_enemy_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQExitGame)
 private:
  inline void set_has_req_msg();
  inline void clear_has_req_msg();
  inline void set_has_exit_table_id();
  inline void clear_has_exit_table_id();
  inline void set_has_exit_user_id();
  inline void clear_has_exit_user_id();
  inline void set_has_enemy_user_id();
  inline void clear_has_enemy_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* req_msg_;
  ::google::protobuf::int32 exit_table_id_;
  ::google::protobuf::int32 exit_user_id_;
  ::google::protobuf::int32 enemy_user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQExitGame* default_instance_;
};
// -------------------------------------------------------------------

class ACKExitGame : public ::google::protobuf::Message {
 public:
  ACKExitGame();
  virtual ~ACKExitGame();

  ACKExitGame(const ACKExitGame& from);

  inline ACKExitGame& operator=(const ACKExitGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKExitGame& default_instance();

  void Swap(ACKExitGame* other);

  // implements Message ----------------------------------------------

  ACKExitGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKExitGame& from);
  void MergeFrom(const ACKExitGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required bytes result_msg = 2;
  inline bool has_result_msg() const;
  inline void clear_result_msg();
  static const int kResultMsgFieldNumber = 2;
  inline const ::std::string& result_msg() const;
  inline void set_result_msg(const ::std::string& value);
  inline void set_result_msg(const char* value);
  inline void set_result_msg(const void* value, size_t size);
  inline ::std::string* mutable_result_msg();
  inline ::std::string* release_result_msg();
  inline void set_allocated_result_msg(::std::string* result_msg);

  // optional int32 exit_table_id = 3;
  inline bool has_exit_table_id() const;
  inline void clear_exit_table_id();
  static const int kExitTableIdFieldNumber = 3;
  inline ::google::protobuf::int32 exit_table_id() const;
  inline void set_exit_table_id(::google::protobuf::int32 value);

  // optional int32 exit_user_id = 4;
  inline bool has_exit_user_id() const;
  inline void clear_exit_user_id();
  static const int kExitUserIdFieldNumber = 4;
  inline ::google::protobuf::int32 exit_user_id() const;
  inline void set_exit_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ACKExitGame)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_result_msg();
  inline void clear_has_result_msg();
  inline void set_has_exit_table_id();
  inline void clear_has_exit_table_id();
  inline void set_has_exit_user_id();
  inline void clear_has_exit_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_msg_;
  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 exit_table_id_;
  ::google::protobuf::int32 exit_user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKExitGame* default_instance_;
};
// -------------------------------------------------------------------

class REQInviteFriendGame : public ::google::protobuf::Message {
 public:
  REQInviteFriendGame();
  virtual ~REQInviteFriendGame();

  REQInviteFriendGame(const REQInviteFriendGame& from);

  inline REQInviteFriendGame& operator=(const REQInviteFriendGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQInviteFriendGame& default_instance();

  void Swap(REQInviteFriendGame* other);

  // implements Message ----------------------------------------------

  REQInviteFriendGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQInviteFriendGame& from);
  void MergeFrom(const REQInviteFriendGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .UserInfo userinfo = 1;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserinfoFieldNumber = 1;
  inline const ::UserInfo& userinfo() const;
  inline ::UserInfo* mutable_userinfo();
  inline ::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::UserInfo* userinfo);

  // required int32 friend_id = 2;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 2;
  inline ::google::protobuf::int32 friend_id() const;
  inline void set_friend_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQInviteFriendGame)
 private:
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  inline void set_has_friend_id();
  inline void clear_has_friend_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserInfo* userinfo_;
  ::google::protobuf::int32 friend_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQInviteFriendGame* default_instance_;
};
// -------------------------------------------------------------------

class ACKInviteFriendGame : public ::google::protobuf::Message {
 public:
  ACKInviteFriendGame();
  virtual ~ACKInviteFriendGame();

  ACKInviteFriendGame(const ACKInviteFriendGame& from);

  inline ACKInviteFriendGame& operator=(const ACKInviteFriendGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKInviteFriendGame& default_instance();

  void Swap(ACKInviteFriendGame* other);

  // implements Message ----------------------------------------------

  ACKInviteFriendGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKInviteFriendGame& from);
  void MergeFrom(const ACKInviteFriendGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required bytes result_msg = 2;
  inline bool has_result_msg() const;
  inline void clear_result_msg();
  static const int kResultMsgFieldNumber = 2;
  inline const ::std::string& result_msg() const;
  inline void set_result_msg(const ::std::string& value);
  inline void set_result_msg(const char* value);
  inline void set_result_msg(const void* value, size_t size);
  inline ::std::string* mutable_result_msg();
  inline ::std::string* release_result_msg();
  inline void set_allocated_result_msg(::std::string* result_msg);

  // @@protoc_insertion_point(class_scope:ACKInviteFriendGame)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_result_msg();
  inline void clear_has_result_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_msg_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKInviteFriendGame* default_instance_;
};
// -------------------------------------------------------------------

class REQAskInviteFriendGame : public ::google::protobuf::Message {
 public:
  REQAskInviteFriendGame();
  virtual ~REQAskInviteFriendGame();

  REQAskInviteFriendGame(const REQAskInviteFriendGame& from);

  inline REQAskInviteFriendGame& operator=(const REQAskInviteFriendGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const REQAskInviteFriendGame& default_instance();

  void Swap(REQAskInviteFriendGame* other);

  // implements Message ----------------------------------------------

  REQAskInviteFriendGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const REQAskInviteFriendGame& from);
  void MergeFrom(const REQAskInviteFriendGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .UserInfo friend_info = 1;
  inline bool has_friend_info() const;
  inline void clear_friend_info();
  static const int kFriendInfoFieldNumber = 1;
  inline const ::UserInfo& friend_info() const;
  inline ::UserInfo* mutable_friend_info();
  inline ::UserInfo* release_friend_info();
  inline void set_allocated_friend_info(::UserInfo* friend_info);

  // required int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:REQAskInviteFriendGame)
 private:
  inline void set_has_friend_info();
  inline void clear_has_friend_info();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserInfo* friend_info_;
  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static REQAskInviteFriendGame* default_instance_;
};
// -------------------------------------------------------------------

class ACKAskInviteFriendGame : public ::google::protobuf::Message {
 public:
  ACKAskInviteFriendGame();
  virtual ~ACKAskInviteFriendGame();

  ACKAskInviteFriendGame(const ACKAskInviteFriendGame& from);

  inline ACKAskInviteFriendGame& operator=(const ACKAskInviteFriendGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKAskInviteFriendGame& default_instance();

  void Swap(ACKAskInviteFriendGame* other);

  // implements Message ----------------------------------------------

  ACKAskInviteFriendGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKAskInviteFriendGame& from);
  void MergeFrom(const ACKAskInviteFriendGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_agree_invite_game = 1;
  inline bool has_is_agree_invite_game() const;
  inline void clear_is_agree_invite_game();
  static const int kIsAgreeInviteGameFieldNumber = 1;
  inline bool is_agree_invite_game() const;
  inline void set_is_agree_invite_game(bool value);

  // optional .UserInfo userinfo = 2;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserinfoFieldNumber = 2;
  inline const ::UserInfo& userinfo() const;
  inline ::UserInfo* mutable_userinfo();
  inline ::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::UserInfo* userinfo);

  // required int32 friend_id = 3;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 3;
  inline ::google::protobuf::int32 friend_id() const;
  inline void set_friend_id(::google::protobuf::int32 value);

  // optional bytes result_msg = 4;
  inline bool has_result_msg() const;
  inline void clear_result_msg();
  static const int kResultMsgFieldNumber = 4;
  inline const ::std::string& result_msg() const;
  inline void set_result_msg(const ::std::string& value);
  inline void set_result_msg(const char* value);
  inline void set_result_msg(const void* value, size_t size);
  inline ::std::string* mutable_result_msg();
  inline ::std::string* release_result_msg();
  inline void set_allocated_result_msg(::std::string* result_msg);

  // @@protoc_insertion_point(class_scope:ACKAskInviteFriendGame)
 private:
  inline void set_has_is_agree_invite_game();
  inline void clear_has_is_agree_invite_game();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  inline void set_has_friend_id();
  inline void clear_has_friend_id();
  inline void set_has_result_msg();
  inline void clear_has_result_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::UserInfo* userinfo_;
  bool is_agree_invite_game_;
  ::google::protobuf::int32 friend_id_;
  ::std::string* result_msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKAskInviteFriendGame* default_instance_;
};
// -------------------------------------------------------------------

class ACKRefuseInviteFriendGame : public ::google::protobuf::Message {
 public:
  ACKRefuseInviteFriendGame();
  virtual ~ACKRefuseInviteFriendGame();

  ACKRefuseInviteFriendGame(const ACKRefuseInviteFriendGame& from);

  inline ACKRefuseInviteFriendGame& operator=(const ACKRefuseInviteFriendGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACKRefuseInviteFriendGame& default_instance();

  void Swap(ACKRefuseInviteFriendGame* other);

  // implements Message ----------------------------------------------

  ACKRefuseInviteFriendGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACKRefuseInviteFriendGame& from);
  void MergeFrom(const ACKRefuseInviteFriendGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required bytes result_msg = 2;
  inline bool has_result_msg() const;
  inline void clear_result_msg();
  static const int kResultMsgFieldNumber = 2;
  inline const ::std::string& result_msg() const;
  inline void set_result_msg(const ::std::string& value);
  inline void set_result_msg(const char* value);
  inline void set_result_msg(const void* value, size_t size);
  inline ::std::string* mutable_result_msg();
  inline ::std::string* release_result_msg();
  inline void set_allocated_result_msg(::std::string* result_msg);

  // @@protoc_insertion_point(class_scope:ACKRefuseInviteFriendGame)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_result_msg();
  inline void clear_has_result_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* result_msg_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_wzqProtocol_2eproto();
  friend void protobuf_AssignDesc_wzqProtocol_2eproto();
  friend void protobuf_ShutdownFile_wzqProtocol_2eproto();

  void InitAsDefaultInstance();
  static ACKRefuseInviteFriendGame* default_instance_;
};
// ===================================================================


// ===================================================================

// REQHold

// -------------------------------------------------------------------

// ACKHold

// optional int32 result_id = 1;
inline bool ACKHold::has_result_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKHold::set_has_result_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKHold::clear_has_result_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKHold::clear_result_id() {
  result_id_ = 0;
  clear_has_result_id();
}
inline ::google::protobuf::int32 ACKHold::result_id() const {
  return result_id_;
}
inline void ACKHold::set_result_id(::google::protobuf::int32 value) {
  set_has_result_id();
  result_id_ = value;
}

// -------------------------------------------------------------------

// MsgPackage

// optional int64 msg_id = 1;
inline bool MsgPackage::has_msg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgPackage::set_has_msg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgPackage::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgPackage::clear_msg_id() {
  msg_id_ = GOOGLE_LONGLONG(0);
  clear_has_msg_id();
}
inline ::google::protobuf::int64 MsgPackage::msg_id() const {
  return msg_id_;
}
inline void MsgPackage::set_msg_id(::google::protobuf::int64 value) {
  set_has_msg_id();
  msg_id_ = value;
}

// optional int64 seq_id = 2;
inline bool MsgPackage::has_seq_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgPackage::set_has_seq_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgPackage::clear_has_seq_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgPackage::clear_seq_id() {
  seq_id_ = GOOGLE_LONGLONG(0);
  clear_has_seq_id();
}
inline ::google::protobuf::int64 MsgPackage::seq_id() const {
  return seq_id_;
}
inline void MsgPackage::set_seq_id(::google::protobuf::int64 value) {
  set_has_seq_id();
  seq_id_ = value;
}

// optional int64 user_id = 3;
inline bool MsgPackage::has_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgPackage::set_has_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgPackage::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgPackage::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 MsgPackage::user_id() const {
  return user_id_;
}
inline void MsgPackage::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
}

// optional bytes msg = 4;
inline bool MsgPackage::has_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgPackage::set_has_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgPackage::clear_has_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgPackage::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& MsgPackage::msg() const {
  return *msg_;
}
inline void MsgPackage::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void MsgPackage::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void MsgPackage::set_msg(const void* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgPackage::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* MsgPackage::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MsgPackage::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes src = 5;
inline bool MsgPackage::has_src() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgPackage::set_has_src() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgPackage::clear_has_src() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgPackage::clear_src() {
  if (src_ != &::google::protobuf::internal::kEmptyString) {
    src_->clear();
  }
  clear_has_src();
}
inline const ::std::string& MsgPackage::src() const {
  return *src_;
}
inline void MsgPackage::set_src(const ::std::string& value) {
  set_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    src_ = new ::std::string;
  }
  src_->assign(value);
}
inline void MsgPackage::set_src(const char* value) {
  set_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    src_ = new ::std::string;
  }
  src_->assign(value);
}
inline void MsgPackage::set_src(const void* value, size_t size) {
  set_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    src_ = new ::std::string;
  }
  src_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgPackage::mutable_src() {
  set_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    src_ = new ::std::string;
  }
  return src_;
}
inline ::std::string* MsgPackage::release_src() {
  clear_has_src();
  if (src_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src_;
    src_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MsgPackage::set_allocated_src(::std::string* src) {
  if (src_ != &::google::protobuf::internal::kEmptyString) {
    delete src_;
  }
  if (src) {
    set_has_src();
    src_ = src;
  } else {
    clear_has_src();
    src_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 clientid = 6;
inline bool MsgPackage::has_clientid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgPackage::set_has_clientid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgPackage::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgPackage::clear_clientid() {
  clientid_ = GOOGLE_LONGLONG(0);
  clear_has_clientid();
}
inline ::google::protobuf::int64 MsgPackage::clientid() const {
  return clientid_;
}
inline void MsgPackage::set_clientid(::google::protobuf::int64 value) {
  set_has_clientid();
  clientid_ = value;
}

// -------------------------------------------------------------------

// REQRegister

// optional bytes account = 1;
inline bool REQRegister::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQRegister::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQRegister::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQRegister::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& REQRegister::account() const {
  return *account_;
}
inline void REQRegister::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void REQRegister::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void REQRegister::set_account(const void* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQRegister::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* REQRegister::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void REQRegister::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes passwd = 2;
inline bool REQRegister::has_passwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQRegister::set_has_passwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQRegister::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQRegister::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& REQRegister::passwd() const {
  return *passwd_;
}
inline void REQRegister::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void REQRegister::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void REQRegister::set_passwd(const void* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQRegister::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* REQRegister::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void REQRegister::set_allocated_passwd(::std::string* passwd) {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    delete passwd_;
  }
  if (passwd) {
    set_has_passwd();
    passwd_ = passwd;
  } else {
    clear_has_passwd();
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ACKRegister

// optional int32 code = 1;
inline bool ACKRegister::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKRegister::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKRegister::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKRegister::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKRegister::code() const {
  return code_;
}
inline void ACKRegister::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional bytes result = 2;
inline bool ACKRegister::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKRegister::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKRegister::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKRegister::clear_result() {
  if (result_ != &::google::protobuf::internal::kEmptyString) {
    result_->clear();
  }
  clear_has_result();
}
inline const ::std::string& ACKRegister::result() const {
  return *result_;
}
inline void ACKRegister::set_result(const ::std::string& value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void ACKRegister::set_result(const char* value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void ACKRegister::set_result(const void* value, size_t size) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKRegister::mutable_result() {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  return result_;
}
inline ::std::string* ACKRegister::release_result() {
  clear_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_;
    result_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKRegister::set_allocated_result(::std::string* result) {
  if (result_ != &::google::protobuf::internal::kEmptyString) {
    delete result_;
  }
  if (result) {
    set_has_result();
    result_ = result;
  } else {
    clear_has_result();
    result_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// REQLogin

// optional bytes account = 1;
inline bool REQLogin::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQLogin::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQLogin::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQLogin::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& REQLogin::account() const {
  return *account_;
}
inline void REQLogin::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void REQLogin::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void REQLogin::set_account(const void* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQLogin::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* REQLogin::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void REQLogin::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes passwd = 2;
inline bool REQLogin::has_passwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQLogin::set_has_passwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQLogin::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQLogin::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& REQLogin::passwd() const {
  return *passwd_;
}
inline void REQLogin::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void REQLogin::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void REQLogin::set_passwd(const void* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQLogin::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* REQLogin::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void REQLogin::set_allocated_passwd(::std::string* passwd) {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    delete passwd_;
  }
  if (passwd) {
    set_has_passwd();
    passwd_ = passwd;
  } else {
    clear_has_passwd();
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ACKLogin

// optional int32 code = 1;
inline bool ACKLogin::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKLogin::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKLogin::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKLogin::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKLogin::code() const {
  return code_;
}
inline void ACKLogin::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional .UserInfo userinfo = 2;
inline bool ACKLogin::has_userinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKLogin::set_has_userinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKLogin::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKLogin::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::UserInfo& ACKLogin::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::UserInfo* ACKLogin::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::UserInfo;
  return userinfo_;
}
inline ::UserInfo* ACKLogin::release_userinfo() {
  clear_has_userinfo();
  ::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void ACKLogin::set_allocated_userinfo(::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
}

// -------------------------------------------------------------------

// UserInfo_Prop

// optional int32 id = 1;
inline bool UserInfo_Prop::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo_Prop::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo_Prop::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo_Prop::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UserInfo_Prop::id() const {
  return id_;
}
inline void UserInfo_Prop::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 quantity = 2;
inline bool UserInfo_Prop::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo_Prop::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo_Prop::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo_Prop::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline ::google::protobuf::int32 UserInfo_Prop::quantity() const {
  return quantity_;
}
inline void UserInfo_Prop::set_quantity(::google::protobuf::int32 value) {
  set_has_quantity();
  quantity_ = value;
}

// -------------------------------------------------------------------

// UserInfo

// optional int32 id = 1;
inline bool UserInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UserInfo::id() const {
  return id_;
}
inline void UserInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional bytes username = 2;
inline bool UserInfo::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& UserInfo::username() const {
  return *username_;
}
inline void UserInfo::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void UserInfo::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void UserInfo::set_username(const void* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* UserInfo::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 wintimes = 3;
inline bool UserInfo::has_wintimes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_wintimes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_wintimes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_wintimes() {
  wintimes_ = 0;
  clear_has_wintimes();
}
inline ::google::protobuf::int32 UserInfo::wintimes() const {
  return wintimes_;
}
inline void UserInfo::set_wintimes(::google::protobuf::int32 value) {
  set_has_wintimes();
  wintimes_ = value;
}

// optional int32 losetimes = 4;
inline bool UserInfo::has_losetimes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_losetimes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_losetimes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_losetimes() {
  losetimes_ = 0;
  clear_has_losetimes();
}
inline ::google::protobuf::int32 UserInfo::losetimes() const {
  return losetimes_;
}
inline void UserInfo::set_losetimes(::google::protobuf::int32 value) {
  set_has_losetimes();
  losetimes_ = value;
}

// optional int32 score = 5;
inline bool UserInfo::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 UserInfo::score() const {
  return score_;
}
inline void UserInfo::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// optional int32 level = 6;
inline bool UserInfo::has_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 UserInfo::level() const {
  return level_;
}
inline void UserInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 xp = 7;
inline bool UserInfo::has_xp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfo::set_has_xp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfo::clear_has_xp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfo::clear_xp() {
  xp_ = 0;
  clear_has_xp();
}
inline ::google::protobuf::int32 UserInfo::xp() const {
  return xp_;
}
inline void UserInfo::set_xp(::google::protobuf::int32 value) {
  set_has_xp();
  xp_ = value;
}

// optional int32 head_id = 8;
inline bool UserInfo::has_head_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfo::set_has_head_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfo::clear_has_head_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfo::clear_head_id() {
  head_id_ = 0;
  clear_has_head_id();
}
inline ::google::protobuf::int32 UserInfo::head_id() const {
  return head_id_;
}
inline void UserInfo::set_head_id(::google::protobuf::int32 value) {
  set_has_head_id();
  head_id_ = value;
}

// optional bool is_online = 9;
inline bool UserInfo::has_is_online() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfo::set_has_is_online() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfo::clear_has_is_online() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfo::clear_is_online() {
  is_online_ = false;
  clear_has_is_online();
}
inline bool UserInfo::is_online() const {
  return is_online_;
}
inline void UserInfo::set_is_online(bool value) {
  set_has_is_online();
  is_online_ = value;
}

// optional int32 coins = 10;
inline bool UserInfo::has_coins() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserInfo::set_has_coins() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserInfo::clear_has_coins() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserInfo::clear_coins() {
  coins_ = 0;
  clear_has_coins();
}
inline ::google::protobuf::int32 UserInfo::coins() const {
  return coins_;
}
inline void UserInfo::set_coins(::google::protobuf::int32 value) {
  set_has_coins();
  coins_ = value;
}

// repeated .UserInfo.Prop props = 11;
inline int UserInfo::props_size() const {
  return props_.size();
}
inline void UserInfo::clear_props() {
  props_.Clear();
}
inline const ::UserInfo_Prop& UserInfo::props(int index) const {
  return props_.Get(index);
}
inline ::UserInfo_Prop* UserInfo::mutable_props(int index) {
  return props_.Mutable(index);
}
inline ::UserInfo_Prop* UserInfo::add_props() {
  return props_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UserInfo_Prop >&
UserInfo::props() const {
  return props_;
}
inline ::google::protobuf::RepeatedPtrField< ::UserInfo_Prop >*
UserInfo::mutable_props() {
  return &props_;
}

// -------------------------------------------------------------------

// REQRoom

// optional bytes req_msg = 1;
inline bool REQRoom::has_req_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQRoom::set_has_req_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQRoom::clear_has_req_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQRoom::clear_req_msg() {
  if (req_msg_ != &::google::protobuf::internal::kEmptyString) {
    req_msg_->clear();
  }
  clear_has_req_msg();
}
inline const ::std::string& REQRoom::req_msg() const {
  return *req_msg_;
}
inline void REQRoom::set_req_msg(const ::std::string& value) {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  req_msg_->assign(value);
}
inline void REQRoom::set_req_msg(const char* value) {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  req_msg_->assign(value);
}
inline void REQRoom::set_req_msg(const void* value, size_t size) {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  req_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQRoom::mutable_req_msg() {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  return req_msg_;
}
inline ::std::string* REQRoom::release_req_msg() {
  clear_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = req_msg_;
    req_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void REQRoom::set_allocated_req_msg(::std::string* req_msg) {
  if (req_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete req_msg_;
  }
  if (req_msg) {
    set_has_req_msg();
    req_msg_ = req_msg;
  } else {
    clear_has_req_msg();
    req_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .UserInfo userinfo = 2;
inline bool REQRoom::has_userinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQRoom::set_has_userinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQRoom::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQRoom::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::UserInfo& REQRoom::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::UserInfo* REQRoom::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::UserInfo;
  return userinfo_;
}
inline ::UserInfo* REQRoom::release_userinfo() {
  clear_has_userinfo();
  ::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void REQRoom::set_allocated_userinfo(::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
}

// -------------------------------------------------------------------

// ACKRoom

// optional int32 code = 1;
inline bool ACKRoom::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKRoom::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKRoom::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKRoom::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKRoom::code() const {
  return code_;
}
inline void ACKRoom::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional bytes result_msg = 2;
inline bool ACKRoom::has_result_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKRoom::set_has_result_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKRoom::clear_has_result_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKRoom::clear_result_msg() {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    result_msg_->clear();
  }
  clear_has_result_msg();
}
inline const ::std::string& ACKRoom::result_msg() const {
  return *result_msg_;
}
inline void ACKRoom::set_result_msg(const ::std::string& value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKRoom::set_result_msg(const char* value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKRoom::set_result_msg(const void* value, size_t size) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKRoom::mutable_result_msg() {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  return result_msg_;
}
inline ::std::string* ACKRoom::release_result_msg() {
  clear_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_msg_;
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKRoom::set_allocated_result_msg(::std::string* result_msg) {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete result_msg_;
  }
  if (result_msg) {
    set_has_result_msg();
    result_msg_ = result_msg;
  } else {
    clear_has_result_msg();
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .UserInfo userinfo = 3;
inline bool ACKRoom::has_userinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKRoom::set_has_userinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKRoom::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKRoom::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::UserInfo& ACKRoom::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::UserInfo* ACKRoom::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::UserInfo;
  return userinfo_;
}
inline ::UserInfo* ACKRoom::release_userinfo() {
  clear_has_userinfo();
  ::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void ACKRoom::set_allocated_userinfo(::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
}

// required int32 black_id = 4;
inline bool ACKRoom::has_black_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACKRoom::set_has_black_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACKRoom::clear_has_black_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACKRoom::clear_black_id() {
  black_id_ = 0;
  clear_has_black_id();
}
inline ::google::protobuf::int32 ACKRoom::black_id() const {
  return black_id_;
}
inline void ACKRoom::set_black_id(::google::protobuf::int32 value) {
  set_has_black_id();
  black_id_ = value;
}

// required int32 white_id = 5;
inline bool ACKRoom::has_white_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ACKRoom::set_has_white_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ACKRoom::clear_has_white_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ACKRoom::clear_white_id() {
  white_id_ = 0;
  clear_has_white_id();
}
inline ::google::protobuf::int32 ACKRoom::white_id() const {
  return white_id_;
}
inline void ACKRoom::set_white_id(::google::protobuf::int32 value) {
  set_has_white_id();
  white_id_ = value;
}

// -------------------------------------------------------------------

// REQEditHead

// optional int32 head_num = 1;
inline bool REQEditHead::has_head_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQEditHead::set_has_head_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQEditHead::clear_has_head_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQEditHead::clear_head_num() {
  head_num_ = 0;
  clear_has_head_num();
}
inline ::google::protobuf::int32 REQEditHead::head_num() const {
  return head_num_;
}
inline void REQEditHead::set_head_num(::google::protobuf::int32 value) {
  set_has_head_num();
  head_num_ = value;
}

// optional bytes user_name = 2;
inline bool REQEditHead::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQEditHead::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQEditHead::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQEditHead::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& REQEditHead::user_name() const {
  return *user_name_;
}
inline void REQEditHead::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void REQEditHead::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void REQEditHead::set_user_name(const void* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQEditHead::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* REQEditHead::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void REQEditHead::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ACKEditHead

// optional int32 code = 1;
inline bool ACKEditHead::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKEditHead::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKEditHead::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKEditHead::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKEditHead::code() const {
  return code_;
}
inline void ACKEditHead::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// REQForcExit

// optional int32 user_id = 1;
inline bool REQForcExit::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQForcExit::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQForcExit::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQForcExit::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQForcExit::user_id() const {
  return user_id_;
}
inline void REQForcExit::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// REQExitAccount

// required int32 user_id = 1;
inline bool REQExitAccount::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQExitAccount::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQExitAccount::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQExitAccount::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQExitAccount::user_id() const {
  return user_id_;
}
inline void REQExitAccount::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// REQRequestFriend

// required int32 num = 1;
inline bool REQRequestFriend::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQRequestFriend::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQRequestFriend::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQRequestFriend::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 REQRequestFriend::num() const {
  return num_;
}
inline void REQRequestFriend::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// required int32 user_id = 2;
inline bool REQRequestFriend::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQRequestFriend::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQRequestFriend::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQRequestFriend::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQRequestFriend::user_id() const {
  return user_id_;
}
inline void REQRequestFriend::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// ACKUpdateFriend

// required int32 user_id = 1;
inline bool ACKUpdateFriend::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKUpdateFriend::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKUpdateFriend::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKUpdateFriend::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 ACKUpdateFriend::user_id() const {
  return user_id_;
}
inline void ACKUpdateFriend::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required .UserInfo firendinfo = 2;
inline bool ACKUpdateFriend::has_firendinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKUpdateFriend::set_has_firendinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKUpdateFriend::clear_has_firendinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKUpdateFriend::clear_firendinfo() {
  if (firendinfo_ != NULL) firendinfo_->::UserInfo::Clear();
  clear_has_firendinfo();
}
inline const ::UserInfo& ACKUpdateFriend::firendinfo() const {
  return firendinfo_ != NULL ? *firendinfo_ : *default_instance_->firendinfo_;
}
inline ::UserInfo* ACKUpdateFriend::mutable_firendinfo() {
  set_has_firendinfo();
  if (firendinfo_ == NULL) firendinfo_ = new ::UserInfo;
  return firendinfo_;
}
inline ::UserInfo* ACKUpdateFriend::release_firendinfo() {
  clear_has_firendinfo();
  ::UserInfo* temp = firendinfo_;
  firendinfo_ = NULL;
  return temp;
}
inline void ACKUpdateFriend::set_allocated_firendinfo(::UserInfo* firendinfo) {
  delete firendinfo_;
  firendinfo_ = firendinfo;
  if (firendinfo) {
    set_has_firendinfo();
  } else {
    clear_has_firendinfo();
  }
}

// -------------------------------------------------------------------

// REQContinueGame

// required int32 user_id = 1;
inline bool REQContinueGame::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQContinueGame::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQContinueGame::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQContinueGame::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQContinueGame::user_id() const {
  return user_id_;
}
inline void REQContinueGame::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 enemy_user_id = 2;
inline bool REQContinueGame::has_enemy_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQContinueGame::set_has_enemy_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQContinueGame::clear_has_enemy_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQContinueGame::clear_enemy_user_id() {
  enemy_user_id_ = 0;
  clear_has_enemy_user_id();
}
inline ::google::protobuf::int32 REQContinueGame::enemy_user_id() const {
  return enemy_user_id_;
}
inline void REQContinueGame::set_enemy_user_id(::google::protobuf::int32 value) {
  set_has_enemy_user_id();
  enemy_user_id_ = value;
}

// required int32 table_id = 3;
inline bool REQContinueGame::has_table_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQContinueGame::set_has_table_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQContinueGame::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQContinueGame::clear_table_id() {
  table_id_ = 0;
  clear_has_table_id();
}
inline ::google::protobuf::int32 REQContinueGame::table_id() const {
  return table_id_;
}
inline void REQContinueGame::set_table_id(::google::protobuf::int32 value) {
  set_has_table_id();
  table_id_ = value;
}

// -------------------------------------------------------------------

// ACKContinueGame

// required int32 code = 1;
inline bool ACKContinueGame::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKContinueGame::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKContinueGame::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKContinueGame::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKContinueGame::code() const {
  return code_;
}
inline void ACKContinueGame::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required bytes result_msg = 2;
inline bool ACKContinueGame::has_result_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKContinueGame::set_has_result_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKContinueGame::clear_has_result_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKContinueGame::clear_result_msg() {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    result_msg_->clear();
  }
  clear_has_result_msg();
}
inline const ::std::string& ACKContinueGame::result_msg() const {
  return *result_msg_;
}
inline void ACKContinueGame::set_result_msg(const ::std::string& value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKContinueGame::set_result_msg(const char* value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKContinueGame::set_result_msg(const void* value, size_t size) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKContinueGame::mutable_result_msg() {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  return result_msg_;
}
inline ::std::string* ACKContinueGame::release_result_msg() {
  clear_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_msg_;
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKContinueGame::set_allocated_result_msg(::std::string* result_msg) {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete result_msg_;
  }
  if (result_msg) {
    set_has_result_msg();
    result_msg_ = result_msg;
  } else {
    clear_has_result_msg();
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// REQAskContinueGame

// required int32 enemy_user_id = 1;
inline bool REQAskContinueGame::has_enemy_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQAskContinueGame::set_has_enemy_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQAskContinueGame::clear_has_enemy_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQAskContinueGame::clear_enemy_user_id() {
  enemy_user_id_ = 0;
  clear_has_enemy_user_id();
}
inline ::google::protobuf::int32 REQAskContinueGame::enemy_user_id() const {
  return enemy_user_id_;
}
inline void REQAskContinueGame::set_enemy_user_id(::google::protobuf::int32 value) {
  set_has_enemy_user_id();
  enemy_user_id_ = value;
}

// required int32 user_id = 2;
inline bool REQAskContinueGame::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQAskContinueGame::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQAskContinueGame::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQAskContinueGame::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQAskContinueGame::user_id() const {
  return user_id_;
}
inline void REQAskContinueGame::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 table_id = 3;
inline bool REQAskContinueGame::has_table_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQAskContinueGame::set_has_table_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQAskContinueGame::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQAskContinueGame::clear_table_id() {
  table_id_ = 0;
  clear_has_table_id();
}
inline ::google::protobuf::int32 REQAskContinueGame::table_id() const {
  return table_id_;
}
inline void REQAskContinueGame::set_table_id(::google::protobuf::int32 value) {
  set_has_table_id();
  table_id_ = value;
}

// -------------------------------------------------------------------

// ACKAskContinueGame

// required bool is_agree_continue_game = 1;
inline bool ACKAskContinueGame::has_is_agree_continue_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKAskContinueGame::set_has_is_agree_continue_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKAskContinueGame::clear_has_is_agree_continue_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKAskContinueGame::clear_is_agree_continue_game() {
  is_agree_continue_game_ = false;
  clear_has_is_agree_continue_game();
}
inline bool ACKAskContinueGame::is_agree_continue_game() const {
  return is_agree_continue_game_;
}
inline void ACKAskContinueGame::set_is_agree_continue_game(bool value) {
  set_has_is_agree_continue_game();
  is_agree_continue_game_ = value;
}

// required int32 enemy_user_id = 2;
inline bool ACKAskContinueGame::has_enemy_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKAskContinueGame::set_has_enemy_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKAskContinueGame::clear_has_enemy_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKAskContinueGame::clear_enemy_user_id() {
  enemy_user_id_ = 0;
  clear_has_enemy_user_id();
}
inline ::google::protobuf::int32 ACKAskContinueGame::enemy_user_id() const {
  return enemy_user_id_;
}
inline void ACKAskContinueGame::set_enemy_user_id(::google::protobuf::int32 value) {
  set_has_enemy_user_id();
  enemy_user_id_ = value;
}

// required int32 user_id = 3;
inline bool ACKAskContinueGame::has_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKAskContinueGame::set_has_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKAskContinueGame::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKAskContinueGame::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 ACKAskContinueGame::user_id() const {
  return user_id_;
}
inline void ACKAskContinueGame::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 table_id = 4;
inline bool ACKAskContinueGame::has_table_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACKAskContinueGame::set_has_table_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACKAskContinueGame::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACKAskContinueGame::clear_table_id() {
  table_id_ = 0;
  clear_has_table_id();
}
inline ::google::protobuf::int32 ACKAskContinueGame::table_id() const {
  return table_id_;
}
inline void ACKAskContinueGame::set_table_id(::google::protobuf::int32 value) {
  set_has_table_id();
  table_id_ = value;
}

// -------------------------------------------------------------------

// ACKRefuseContinueGame

// required int32 code = 1;
inline bool ACKRefuseContinueGame::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKRefuseContinueGame::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKRefuseContinueGame::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKRefuseContinueGame::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKRefuseContinueGame::code() const {
  return code_;
}
inline void ACKRefuseContinueGame::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required bytes result_msg = 2;
inline bool ACKRefuseContinueGame::has_result_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKRefuseContinueGame::set_has_result_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKRefuseContinueGame::clear_has_result_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKRefuseContinueGame::clear_result_msg() {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    result_msg_->clear();
  }
  clear_has_result_msg();
}
inline const ::std::string& ACKRefuseContinueGame::result_msg() const {
  return *result_msg_;
}
inline void ACKRefuseContinueGame::set_result_msg(const ::std::string& value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKRefuseContinueGame::set_result_msg(const char* value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKRefuseContinueGame::set_result_msg(const void* value, size_t size) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKRefuseContinueGame::mutable_result_msg() {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  return result_msg_;
}
inline ::std::string* ACKRefuseContinueGame::release_result_msg() {
  clear_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_msg_;
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKRefuseContinueGame::set_allocated_result_msg(::std::string* result_msg) {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete result_msg_;
  }
  if (result_msg) {
    set_has_result_msg();
    result_msg_ = result_msg;
  } else {
    clear_has_result_msg();
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ACKFriendsList

// repeated .UserInfo firendinfo = 1;
inline int ACKFriendsList::firendinfo_size() const {
  return firendinfo_.size();
}
inline void ACKFriendsList::clear_firendinfo() {
  firendinfo_.Clear();
}
inline const ::UserInfo& ACKFriendsList::firendinfo(int index) const {
  return firendinfo_.Get(index);
}
inline ::UserInfo* ACKFriendsList::mutable_firendinfo(int index) {
  return firendinfo_.Mutable(index);
}
inline ::UserInfo* ACKFriendsList::add_firendinfo() {
  return firendinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UserInfo >&
ACKFriendsList::firendinfo() const {
  return firendinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::UserInfo >*
ACKFriendsList::mutable_firendinfo() {
  return &firendinfo_;
}

// -------------------------------------------------------------------

// REQExitGame

// required bytes req_msg = 1;
inline bool REQExitGame::has_req_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQExitGame::set_has_req_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQExitGame::clear_has_req_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQExitGame::clear_req_msg() {
  if (req_msg_ != &::google::protobuf::internal::kEmptyString) {
    req_msg_->clear();
  }
  clear_has_req_msg();
}
inline const ::std::string& REQExitGame::req_msg() const {
  return *req_msg_;
}
inline void REQExitGame::set_req_msg(const ::std::string& value) {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  req_msg_->assign(value);
}
inline void REQExitGame::set_req_msg(const char* value) {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  req_msg_->assign(value);
}
inline void REQExitGame::set_req_msg(const void* value, size_t size) {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  req_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* REQExitGame::mutable_req_msg() {
  set_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    req_msg_ = new ::std::string;
  }
  return req_msg_;
}
inline ::std::string* REQExitGame::release_req_msg() {
  clear_has_req_msg();
  if (req_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = req_msg_;
    req_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void REQExitGame::set_allocated_req_msg(::std::string* req_msg) {
  if (req_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete req_msg_;
  }
  if (req_msg) {
    set_has_req_msg();
    req_msg_ = req_msg;
  } else {
    clear_has_req_msg();
    req_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 exit_table_id = 2;
inline bool REQExitGame::has_exit_table_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQExitGame::set_has_exit_table_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQExitGame::clear_has_exit_table_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQExitGame::clear_exit_table_id() {
  exit_table_id_ = 0;
  clear_has_exit_table_id();
}
inline ::google::protobuf::int32 REQExitGame::exit_table_id() const {
  return exit_table_id_;
}
inline void REQExitGame::set_exit_table_id(::google::protobuf::int32 value) {
  set_has_exit_table_id();
  exit_table_id_ = value;
}

// required int32 exit_user_id = 3;
inline bool REQExitGame::has_exit_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void REQExitGame::set_has_exit_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void REQExitGame::clear_has_exit_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void REQExitGame::clear_exit_user_id() {
  exit_user_id_ = 0;
  clear_has_exit_user_id();
}
inline ::google::protobuf::int32 REQExitGame::exit_user_id() const {
  return exit_user_id_;
}
inline void REQExitGame::set_exit_user_id(::google::protobuf::int32 value) {
  set_has_exit_user_id();
  exit_user_id_ = value;
}

// required int32 enemy_user_id = 4;
inline bool REQExitGame::has_enemy_user_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void REQExitGame::set_has_enemy_user_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void REQExitGame::clear_has_enemy_user_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void REQExitGame::clear_enemy_user_id() {
  enemy_user_id_ = 0;
  clear_has_enemy_user_id();
}
inline ::google::protobuf::int32 REQExitGame::enemy_user_id() const {
  return enemy_user_id_;
}
inline void REQExitGame::set_enemy_user_id(::google::protobuf::int32 value) {
  set_has_enemy_user_id();
  enemy_user_id_ = value;
}

// -------------------------------------------------------------------

// ACKExitGame

// required int32 code = 1;
inline bool ACKExitGame::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKExitGame::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKExitGame::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKExitGame::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKExitGame::code() const {
  return code_;
}
inline void ACKExitGame::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required bytes result_msg = 2;
inline bool ACKExitGame::has_result_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKExitGame::set_has_result_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKExitGame::clear_has_result_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKExitGame::clear_result_msg() {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    result_msg_->clear();
  }
  clear_has_result_msg();
}
inline const ::std::string& ACKExitGame::result_msg() const {
  return *result_msg_;
}
inline void ACKExitGame::set_result_msg(const ::std::string& value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKExitGame::set_result_msg(const char* value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKExitGame::set_result_msg(const void* value, size_t size) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKExitGame::mutable_result_msg() {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  return result_msg_;
}
inline ::std::string* ACKExitGame::release_result_msg() {
  clear_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_msg_;
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKExitGame::set_allocated_result_msg(::std::string* result_msg) {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete result_msg_;
  }
  if (result_msg) {
    set_has_result_msg();
    result_msg_ = result_msg;
  } else {
    clear_has_result_msg();
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 exit_table_id = 3;
inline bool ACKExitGame::has_exit_table_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKExitGame::set_has_exit_table_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKExitGame::clear_has_exit_table_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKExitGame::clear_exit_table_id() {
  exit_table_id_ = 0;
  clear_has_exit_table_id();
}
inline ::google::protobuf::int32 ACKExitGame::exit_table_id() const {
  return exit_table_id_;
}
inline void ACKExitGame::set_exit_table_id(::google::protobuf::int32 value) {
  set_has_exit_table_id();
  exit_table_id_ = value;
}

// optional int32 exit_user_id = 4;
inline bool ACKExitGame::has_exit_user_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACKExitGame::set_has_exit_user_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACKExitGame::clear_has_exit_user_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACKExitGame::clear_exit_user_id() {
  exit_user_id_ = 0;
  clear_has_exit_user_id();
}
inline ::google::protobuf::int32 ACKExitGame::exit_user_id() const {
  return exit_user_id_;
}
inline void ACKExitGame::set_exit_user_id(::google::protobuf::int32 value) {
  set_has_exit_user_id();
  exit_user_id_ = value;
}

// -------------------------------------------------------------------

// REQInviteFriendGame

// optional .UserInfo userinfo = 1;
inline bool REQInviteFriendGame::has_userinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQInviteFriendGame::set_has_userinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQInviteFriendGame::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQInviteFriendGame::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::UserInfo& REQInviteFriendGame::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::UserInfo* REQInviteFriendGame::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::UserInfo;
  return userinfo_;
}
inline ::UserInfo* REQInviteFriendGame::release_userinfo() {
  clear_has_userinfo();
  ::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void REQInviteFriendGame::set_allocated_userinfo(::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
}

// required int32 friend_id = 2;
inline bool REQInviteFriendGame::has_friend_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQInviteFriendGame::set_has_friend_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQInviteFriendGame::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQInviteFriendGame::clear_friend_id() {
  friend_id_ = 0;
  clear_has_friend_id();
}
inline ::google::protobuf::int32 REQInviteFriendGame::friend_id() const {
  return friend_id_;
}
inline void REQInviteFriendGame::set_friend_id(::google::protobuf::int32 value) {
  set_has_friend_id();
  friend_id_ = value;
}

// -------------------------------------------------------------------

// ACKInviteFriendGame

// required int32 code = 1;
inline bool ACKInviteFriendGame::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKInviteFriendGame::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKInviteFriendGame::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKInviteFriendGame::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKInviteFriendGame::code() const {
  return code_;
}
inline void ACKInviteFriendGame::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required bytes result_msg = 2;
inline bool ACKInviteFriendGame::has_result_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKInviteFriendGame::set_has_result_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKInviteFriendGame::clear_has_result_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKInviteFriendGame::clear_result_msg() {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    result_msg_->clear();
  }
  clear_has_result_msg();
}
inline const ::std::string& ACKInviteFriendGame::result_msg() const {
  return *result_msg_;
}
inline void ACKInviteFriendGame::set_result_msg(const ::std::string& value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKInviteFriendGame::set_result_msg(const char* value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKInviteFriendGame::set_result_msg(const void* value, size_t size) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKInviteFriendGame::mutable_result_msg() {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  return result_msg_;
}
inline ::std::string* ACKInviteFriendGame::release_result_msg() {
  clear_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_msg_;
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKInviteFriendGame::set_allocated_result_msg(::std::string* result_msg) {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete result_msg_;
  }
  if (result_msg) {
    set_has_result_msg();
    result_msg_ = result_msg;
  } else {
    clear_has_result_msg();
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// REQAskInviteFriendGame

// optional .UserInfo friend_info = 1;
inline bool REQAskInviteFriendGame::has_friend_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void REQAskInviteFriendGame::set_has_friend_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void REQAskInviteFriendGame::clear_has_friend_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void REQAskInviteFriendGame::clear_friend_info() {
  if (friend_info_ != NULL) friend_info_->::UserInfo::Clear();
  clear_has_friend_info();
}
inline const ::UserInfo& REQAskInviteFriendGame::friend_info() const {
  return friend_info_ != NULL ? *friend_info_ : *default_instance_->friend_info_;
}
inline ::UserInfo* REQAskInviteFriendGame::mutable_friend_info() {
  set_has_friend_info();
  if (friend_info_ == NULL) friend_info_ = new ::UserInfo;
  return friend_info_;
}
inline ::UserInfo* REQAskInviteFriendGame::release_friend_info() {
  clear_has_friend_info();
  ::UserInfo* temp = friend_info_;
  friend_info_ = NULL;
  return temp;
}
inline void REQAskInviteFriendGame::set_allocated_friend_info(::UserInfo* friend_info) {
  delete friend_info_;
  friend_info_ = friend_info;
  if (friend_info) {
    set_has_friend_info();
  } else {
    clear_has_friend_info();
  }
}

// required int32 user_id = 2;
inline bool REQAskInviteFriendGame::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void REQAskInviteFriendGame::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void REQAskInviteFriendGame::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void REQAskInviteFriendGame::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 REQAskInviteFriendGame::user_id() const {
  return user_id_;
}
inline void REQAskInviteFriendGame::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// ACKAskInviteFriendGame

// required bool is_agree_invite_game = 1;
inline bool ACKAskInviteFriendGame::has_is_agree_invite_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKAskInviteFriendGame::set_has_is_agree_invite_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKAskInviteFriendGame::clear_has_is_agree_invite_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKAskInviteFriendGame::clear_is_agree_invite_game() {
  is_agree_invite_game_ = false;
  clear_has_is_agree_invite_game();
}
inline bool ACKAskInviteFriendGame::is_agree_invite_game() const {
  return is_agree_invite_game_;
}
inline void ACKAskInviteFriendGame::set_is_agree_invite_game(bool value) {
  set_has_is_agree_invite_game();
  is_agree_invite_game_ = value;
}

// optional .UserInfo userinfo = 2;
inline bool ACKAskInviteFriendGame::has_userinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKAskInviteFriendGame::set_has_userinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKAskInviteFriendGame::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKAskInviteFriendGame::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::UserInfo& ACKAskInviteFriendGame::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::UserInfo* ACKAskInviteFriendGame::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::UserInfo;
  return userinfo_;
}
inline ::UserInfo* ACKAskInviteFriendGame::release_userinfo() {
  clear_has_userinfo();
  ::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void ACKAskInviteFriendGame::set_allocated_userinfo(::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
}

// required int32 friend_id = 3;
inline bool ACKAskInviteFriendGame::has_friend_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACKAskInviteFriendGame::set_has_friend_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACKAskInviteFriendGame::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACKAskInviteFriendGame::clear_friend_id() {
  friend_id_ = 0;
  clear_has_friend_id();
}
inline ::google::protobuf::int32 ACKAskInviteFriendGame::friend_id() const {
  return friend_id_;
}
inline void ACKAskInviteFriendGame::set_friend_id(::google::protobuf::int32 value) {
  set_has_friend_id();
  friend_id_ = value;
}

// optional bytes result_msg = 4;
inline bool ACKAskInviteFriendGame::has_result_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACKAskInviteFriendGame::set_has_result_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACKAskInviteFriendGame::clear_has_result_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACKAskInviteFriendGame::clear_result_msg() {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    result_msg_->clear();
  }
  clear_has_result_msg();
}
inline const ::std::string& ACKAskInviteFriendGame::result_msg() const {
  return *result_msg_;
}
inline void ACKAskInviteFriendGame::set_result_msg(const ::std::string& value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKAskInviteFriendGame::set_result_msg(const char* value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKAskInviteFriendGame::set_result_msg(const void* value, size_t size) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKAskInviteFriendGame::mutable_result_msg() {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  return result_msg_;
}
inline ::std::string* ACKAskInviteFriendGame::release_result_msg() {
  clear_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_msg_;
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKAskInviteFriendGame::set_allocated_result_msg(::std::string* result_msg) {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete result_msg_;
  }
  if (result_msg) {
    set_has_result_msg();
    result_msg_ = result_msg;
  } else {
    clear_has_result_msg();
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ACKRefuseInviteFriendGame

// required int32 code = 1;
inline bool ACKRefuseInviteFriendGame::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACKRefuseInviteFriendGame::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACKRefuseInviteFriendGame::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACKRefuseInviteFriendGame::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ACKRefuseInviteFriendGame::code() const {
  return code_;
}
inline void ACKRefuseInviteFriendGame::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required bytes result_msg = 2;
inline bool ACKRefuseInviteFriendGame::has_result_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACKRefuseInviteFriendGame::set_has_result_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACKRefuseInviteFriendGame::clear_has_result_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACKRefuseInviteFriendGame::clear_result_msg() {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    result_msg_->clear();
  }
  clear_has_result_msg();
}
inline const ::std::string& ACKRefuseInviteFriendGame::result_msg() const {
  return *result_msg_;
}
inline void ACKRefuseInviteFriendGame::set_result_msg(const ::std::string& value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKRefuseInviteFriendGame::set_result_msg(const char* value) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(value);
}
inline void ACKRefuseInviteFriendGame::set_result_msg(const void* value, size_t size) {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  result_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACKRefuseInviteFriendGame::mutable_result_msg() {
  set_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    result_msg_ = new ::std::string;
  }
  return result_msg_;
}
inline ::std::string* ACKRefuseInviteFriendGame::release_result_msg() {
  clear_has_result_msg();
  if (result_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_msg_;
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACKRefuseInviteFriendGame::set_allocated_result_msg(::std::string* result_msg) {
  if (result_msg_ != &::google::protobuf::internal::kEmptyString) {
    delete result_msg_;
  }
  if (result_msg) {
    set_has_result_msg();
    result_msg_ = result_msg;
  } else {
    clear_has_result_msg();
    result_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_wzqProtocol_2eproto__INCLUDED
